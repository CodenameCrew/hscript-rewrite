// Generated by Haxe 4.3.7
#include <hxcpp.h>

#ifndef INCLUDED_haxe__Int32_Int32_Impl_
#include <haxe/_Int32/Int32_Impl_.h>
#endif

namespace haxe{
namespace _Int32{

void Int32_Impl__obj::__construct() { }

Dynamic Int32_Impl__obj::__CreateEmpty() { return new Int32_Impl__obj; }

void *Int32_Impl__obj::_hx_vtable = 0;

Dynamic Int32_Impl__obj::__Create(::hx::DynamicArray inArgs)
{
	::hx::ObjectPtr< Int32_Impl__obj > _hx_result = new Int32_Impl__obj();
	_hx_result->__construct();
	return _hx_result;
}

bool Int32_Impl__obj::_hx_isInstanceOf(int inClassId) {
	return inClassId==(int)0x00000001 || inClassId==(int)0x23048859;
}

int Int32_Impl__obj::negate(int this1){
	return (~(this1) + 1);
}


STATIC_HX_DEFINE_DYNAMIC_FUNC1(Int32_Impl__obj,negate,return )

int Int32_Impl__obj::preIncrement(int this1){
	this1 = (this1 + 1);
	int x = this1;
	this1 = x;
	return x;
}


STATIC_HX_DEFINE_DYNAMIC_FUNC1(Int32_Impl__obj,preIncrement,return )

int Int32_Impl__obj::postIncrement(int this1){
	this1 = (this1 + 1);
	return (this1 - 1);
}


STATIC_HX_DEFINE_DYNAMIC_FUNC1(Int32_Impl__obj,postIncrement,return )

int Int32_Impl__obj::preDecrement(int this1){
	this1 = (this1 - 1);
	int x = this1;
	this1 = x;
	return x;
}


STATIC_HX_DEFINE_DYNAMIC_FUNC1(Int32_Impl__obj,preDecrement,return )

int Int32_Impl__obj::postDecrement(int this1){
	this1 = (this1 - 1);
	return (this1 + 1);
}


STATIC_HX_DEFINE_DYNAMIC_FUNC1(Int32_Impl__obj,postDecrement,return )

int Int32_Impl__obj::add(int a,int b){
	return (a + b);
}


STATIC_HX_DEFINE_DYNAMIC_FUNC2(Int32_Impl__obj,add,return )

int Int32_Impl__obj::addInt(int a,int b){
	return (a + b);
}


STATIC_HX_DEFINE_DYNAMIC_FUNC2(Int32_Impl__obj,addInt,return )

int Int32_Impl__obj::sub(int a,int b){
	return (a - b);
}


STATIC_HX_DEFINE_DYNAMIC_FUNC2(Int32_Impl__obj,sub,return )

int Int32_Impl__obj::subInt(int a,int b){
	return (a - b);
}


STATIC_HX_DEFINE_DYNAMIC_FUNC2(Int32_Impl__obj,subInt,return )

int Int32_Impl__obj::intSub(int a,int b){
	return (a - b);
}


STATIC_HX_DEFINE_DYNAMIC_FUNC2(Int32_Impl__obj,intSub,return )

Float Int32_Impl__obj::toFloat(int this1){
	return ( (Float)(this1) );
}


STATIC_HX_DEFINE_DYNAMIC_FUNC1(Int32_Impl__obj,toFloat,return )

int Int32_Impl__obj::ucompare(int a,int b){
	if ((a < 0)) {
		if ((b < 0)) {
			return (~(b) - ~(a));
		}
		else {
			return 1;
		}
	}
	if ((b < 0)) {
		return -1;
	}
	else {
		return (a - b);
	}
	return 0;
}


STATIC_HX_DEFINE_DYNAMIC_FUNC2(Int32_Impl__obj,ucompare,return )

int Int32_Impl__obj::clamp(int x){
	return x;
}


STATIC_HX_DEFINE_DYNAMIC_FUNC1(Int32_Impl__obj,clamp,return )


Int32_Impl__obj::Int32_Impl__obj()
{
}

bool Int32_Impl__obj::__GetStatic(const ::String &inName, Dynamic &outValue, ::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 3:
		if (HX_FIELD_EQ(inName,"add") ) { outValue = add_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"sub") ) { outValue = sub_dyn(); return true; }
		break;
	case 5:
		if (HX_FIELD_EQ(inName,"clamp") ) { outValue = clamp_dyn(); return true; }
		break;
	case 6:
		if (HX_FIELD_EQ(inName,"negate") ) { outValue = negate_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"addInt") ) { outValue = addInt_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"subInt") ) { outValue = subInt_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"intSub") ) { outValue = intSub_dyn(); return true; }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"toFloat") ) { outValue = toFloat_dyn(); return true; }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"ucompare") ) { outValue = ucompare_dyn(); return true; }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"preIncrement") ) { outValue = preIncrement_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"preDecrement") ) { outValue = preDecrement_dyn(); return true; }
		break;
	case 13:
		if (HX_FIELD_EQ(inName,"postIncrement") ) { outValue = postIncrement_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"postDecrement") ) { outValue = postDecrement_dyn(); return true; }
	}
	return false;
}

#ifdef HXCPP_SCRIPTABLE
static ::hx::StorageInfo *Int32_Impl__obj_sMemberStorageInfo = 0;
static ::hx::StaticInfo *Int32_Impl__obj_sStaticStorageInfo = 0;
#endif

::hx::Class Int32_Impl__obj::__mClass;

static ::String Int32_Impl__obj_sStaticFields[] = {
	HX_("negate",c2,41,19,67),
	HX_("preIncrement",8c,e9,fe,d7),
	HX_("postIncrement",af,d5,b1,df),
	HX_("preDecrement",70,d9,81,b6),
	HX_("postDecrement",93,c5,34,be),
	HX_("add",21,f2,49,00),
	HX_("addInt",4e,1d,01,9f),
	HX_("sub",80,a9,57,00),
	HX_("subInt",4f,0b,eb,99),
	HX_("intSub",d1,d3,78,9e),
	HX_("toFloat",21,12,1b,cf),
	HX_("ucompare",d0,40,77,a7),
	HX_("clamp",fb,72,58,48),
	::String(null())
};

void Int32_Impl__obj::__register()
{
	Int32_Impl__obj _hx_dummy;
	Int32_Impl__obj::_hx_vtable = *(void **)&_hx_dummy;
	::hx::Static(__mClass) = new ::hx::Class_obj();
	__mClass->mName = HX_("haxe._Int32.Int32_Impl_",17,9d,21,ce);
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &Int32_Impl__obj::__GetStatic;
	__mClass->mSetStaticField = &::hx::Class_obj::SetNoStaticField;
	__mClass->mStatics = ::hx::Class_obj::dupFunctions(Int32_Impl__obj_sStaticFields);
	__mClass->mMembers = ::hx::Class_obj::dupFunctions(0 /* sMemberFields */);
	__mClass->mCanCast = ::hx::TCanCast< Int32_Impl__obj >;
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = Int32_Impl__obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = Int32_Impl__obj_sStaticStorageInfo;
#endif
	::hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

} // end namespace haxe
} // end namespace _Int32
