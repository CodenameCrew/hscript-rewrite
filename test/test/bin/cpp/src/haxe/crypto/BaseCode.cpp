// Generated by Haxe 4.3.7
#include <hxcpp.h>

#ifndef INCLUDED_Std
#include <Std.h>
#endif
#ifndef INCLUDED_haxe_crypto_BaseCode
#include <haxe/crypto/BaseCode.h>
#endif
#ifndef INCLUDED_haxe_io_Bytes
#include <haxe/io/Bytes.h>
#endif
#ifndef INCLUDED_haxe_io_Encoding
#include <haxe/io/Encoding.h>
#endif

namespace haxe{
namespace crypto{

void BaseCode_obj::__construct( ::haxe::io::Bytes base){
	int len = base->length;
	int nbits = 1;
	while((len > (1 << nbits))){
		nbits = (nbits + 1);
	}
	bool _hx_tmp;
	if ((nbits <= 8)) {
		_hx_tmp = (len != (1 << nbits));
	}
	else {
		_hx_tmp = true;
	}
	if (_hx_tmp) {
		HX_STACK_DO_THROW(HX_("BaseCode : base length must be a power of two.",78,b6,c8,ca));
	}
	this->base = base;
	this->nbits = nbits;
}

Dynamic BaseCode_obj::__CreateEmpty() { return new BaseCode_obj; }

void *BaseCode_obj::_hx_vtable = 0;

Dynamic BaseCode_obj::__Create(::hx::DynamicArray inArgs)
{
	::hx::ObjectPtr< BaseCode_obj > _hx_result = new BaseCode_obj();
	_hx_result->__construct(inArgs[0]);
	return _hx_result;
}

bool BaseCode_obj::_hx_isInstanceOf(int inClassId) {
	return inClassId==(int)0x00000001 || inClassId==(int)0x34980465;
}

 ::haxe::io::Bytes BaseCode_obj::encodeBytes( ::haxe::io::Bytes b){
	int nbits = this->nbits;
	 ::haxe::io::Bytes base = this->base;
	int size = ::Std_obj::_hx_int((( (Float)((b->length * 8)) ) / ( (Float)(nbits) )));
	int out;
	if ((::hx::Mod((b->length * 8),nbits) == 0)) {
		out = 0;
	}
	else {
		out = 1;
	}
	 ::haxe::io::Bytes out1 = ::haxe::io::Bytes_obj::alloc((size + out));
	int buf = 0;
	int curbits = 0;
	int mask = ((1 << nbits) - 1);
	int pin = 0;
	int pout = 0;
	while((pout < size)){
		while((curbits < nbits)){
			curbits = (curbits + 8);
			buf = (buf << 8);
			pin = (pin + 1);
			buf = (buf | ( (int)(b->b->__get((pin - 1))) ));
		}
		curbits = (curbits - nbits);
		{
			pout = (pout + 1);
			out1->b[(pout - 1)] = base->b->__get(((buf >> curbits) & mask));
		}
	}
	if ((curbits > 0)) {
		pout = (pout + 1);
		out1->b[(pout - 1)] = base->b->__get(((buf << (nbits - curbits)) & mask));
	}
	return out1;
}


HX_DEFINE_DYNAMIC_FUNC1(BaseCode_obj,encodeBytes,return )

void BaseCode_obj::initTable(){
	::Array< int > tbl = ::Array_obj< int >::__new();
	{
		int _g = 0;
		while((_g < 256)){
			_g = (_g + 1);
			tbl[(_g - 1)] = -1;
		}
	}
	{
		int _g1 = 0;
		int _g2 = this->base->length;
		while((_g1 < _g2)){
			_g1 = (_g1 + 1);
			int i = (_g1 - 1);
			tbl[( (int)(this->base->b->__get(i)) )] = i;
		}
	}
	this->tbl = tbl;
}


HX_DEFINE_DYNAMIC_FUNC0(BaseCode_obj,initTable,(void))

 ::haxe::io::Bytes BaseCode_obj::decodeBytes( ::haxe::io::Bytes b){
	int nbits = this->nbits;
	if (::hx::IsNull( this->tbl )) {
		this->initTable();
	}
	::Array< int > tbl = this->tbl;
	int size = ((b->length * nbits) >> 3);
	 ::haxe::io::Bytes out = ::haxe::io::Bytes_obj::alloc(size);
	int buf = 0;
	int curbits = 0;
	int pin = 0;
	int pout = 0;
	while((pout < size)){
		while((curbits < 8)){
			curbits = (curbits + nbits);
			buf = (buf << nbits);
			pin = (pin + 1);
			int i = tbl->__get(( (int)(b->b->__get((pin - 1))) ));
			if ((i == -1)) {
				HX_STACK_DO_THROW(HX_("BaseCode : invalid encoded char",f9,14,33,18));
			}
			buf = (buf | i);
		}
		curbits = (curbits - 8);
		{
			pout = (pout + 1);
			out->b[(pout - 1)] = ( (unsigned char)(((buf >> curbits) & 255)) );
		}
	}
	return out;
}


HX_DEFINE_DYNAMIC_FUNC1(BaseCode_obj,decodeBytes,return )

::String BaseCode_obj::encodeString(::String s){
	return this->encodeBytes(::haxe::io::Bytes_obj::ofString(s,null()))->toString();
}


HX_DEFINE_DYNAMIC_FUNC1(BaseCode_obj,encodeString,return )

::String BaseCode_obj::decodeString(::String s){
	return this->decodeBytes(::haxe::io::Bytes_obj::ofString(s,null()))->toString();
}


HX_DEFINE_DYNAMIC_FUNC1(BaseCode_obj,decodeString,return )

::String BaseCode_obj::encode(::String s,::String base){
            	HX_JUST_GC_STACKFRAME
	return  ::haxe::crypto::BaseCode_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::ofString(base,null()))->encodeString(s);
}


STATIC_HX_DEFINE_DYNAMIC_FUNC2(BaseCode_obj,encode,return )

::String BaseCode_obj::decode(::String s,::String base){
            	HX_JUST_GC_STACKFRAME
	return  ::haxe::crypto::BaseCode_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::ofString(base,null()))->decodeString(s);
}


STATIC_HX_DEFINE_DYNAMIC_FUNC2(BaseCode_obj,decode,return )


::hx::ObjectPtr< BaseCode_obj > BaseCode_obj::__new( ::haxe::io::Bytes base) {
	::hx::ObjectPtr< BaseCode_obj > __this = new BaseCode_obj();
	__this->__construct(base);
	return __this;
}

::hx::ObjectPtr< BaseCode_obj > BaseCode_obj::__alloc(::hx::Ctx *_hx_ctx, ::haxe::io::Bytes base) {
	BaseCode_obj *__this = (BaseCode_obj*)(::hx::Ctx::alloc(_hx_ctx, sizeof(BaseCode_obj), true, "haxe.crypto.BaseCode"));
	*(void **)__this = BaseCode_obj::_hx_vtable;
	__this->__construct(base);
	return __this;
}

BaseCode_obj::BaseCode_obj()
{
}

void BaseCode_obj::__Mark(HX_MARK_PARAMS)
{
	HX_MARK_BEGIN_CLASS(BaseCode);
	HX_MARK_MEMBER_NAME(base,"base");
	HX_MARK_MEMBER_NAME(nbits,"nbits");
	HX_MARK_MEMBER_NAME(tbl,"tbl");
	HX_MARK_END_CLASS();
}

void BaseCode_obj::__Visit(HX_VISIT_PARAMS)
{
	HX_VISIT_MEMBER_NAME(base,"base");
	HX_VISIT_MEMBER_NAME(nbits,"nbits");
	HX_VISIT_MEMBER_NAME(tbl,"tbl");
}

::hx::Val BaseCode_obj::__Field(const ::String &inName,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 3:
		if (HX_FIELD_EQ(inName,"tbl") ) { return ::hx::Val( tbl ); }
		break;
	case 4:
		if (HX_FIELD_EQ(inName,"base") ) { return ::hx::Val( base ); }
		break;
	case 5:
		if (HX_FIELD_EQ(inName,"nbits") ) { return ::hx::Val( nbits ); }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"initTable") ) { return ::hx::Val( initTable_dyn() ); }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"encodeBytes") ) { return ::hx::Val( encodeBytes_dyn() ); }
		if (HX_FIELD_EQ(inName,"decodeBytes") ) { return ::hx::Val( decodeBytes_dyn() ); }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"encodeString") ) { return ::hx::Val( encodeString_dyn() ); }
		if (HX_FIELD_EQ(inName,"decodeString") ) { return ::hx::Val( decodeString_dyn() ); }
	}
	return super::__Field(inName,inCallProp);
}

bool BaseCode_obj::__GetStatic(const ::String &inName, Dynamic &outValue, ::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 6:
		if (HX_FIELD_EQ(inName,"encode") ) { outValue = encode_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"decode") ) { outValue = decode_dyn(); return true; }
	}
	return false;
}

::hx::Val BaseCode_obj::__SetField(const ::String &inName,const ::hx::Val &inValue,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 3:
		if (HX_FIELD_EQ(inName,"tbl") ) { tbl=inValue.Cast< ::Array< int > >(); return inValue; }
		break;
	case 4:
		if (HX_FIELD_EQ(inName,"base") ) { base=inValue.Cast<  ::haxe::io::Bytes >(); return inValue; }
		break;
	case 5:
		if (HX_FIELD_EQ(inName,"nbits") ) { nbits=inValue.Cast< int >(); return inValue; }
	}
	return super::__SetField(inName,inValue,inCallProp);
}

void BaseCode_obj::__GetFields(Array< ::String> &outFields)
{
	outFields->push(HX_("base",11,e8,10,41));
	outFields->push(HX_("nbits",74,ca,2a,97));
	outFields->push(HX_("tbl",3e,5b,58,00));
	super::__GetFields(outFields);
};

#ifdef HXCPP_SCRIPTABLE
static ::hx::StorageInfo BaseCode_obj_sMemberStorageInfo[] = {
	{::hx::fsObject /*  ::haxe::io::Bytes */ ,(int)offsetof(BaseCode_obj,base),HX_("base",11,e8,10,41)},
	{::hx::fsInt,(int)offsetof(BaseCode_obj,nbits),HX_("nbits",74,ca,2a,97)},
	{::hx::fsObject /* ::Array< int > */ ,(int)offsetof(BaseCode_obj,tbl),HX_("tbl",3e,5b,58,00)},
	{ ::hx::fsUnknown, 0, null()}
};
static ::hx::StaticInfo *BaseCode_obj_sStaticStorageInfo = 0;
#endif

static ::String BaseCode_obj_sMemberFields[] = {
	HX_("base",11,e8,10,41),
	HX_("nbits",74,ca,2a,97),
	HX_("tbl",3e,5b,58,00),
	HX_("encodeBytes",75,36,2e,c9),
	HX_("initTable",de,d2,75,26),
	HX_("decodeBytes",5d,94,b1,85),
	HX_("encodeString",87,43,02,29),
	HX_("decodeString",9f,10,71,5f),
	::String(null()) };

::hx::Class BaseCode_obj::__mClass;

static ::String BaseCode_obj_sStaticFields[] = {
	HX_("encode",16,f2,e3,f9),
	HX_("decode",2e,5d,ed,64),
	::String(null())
};

void BaseCode_obj::__register()
{
	BaseCode_obj _hx_dummy;
	BaseCode_obj::_hx_vtable = *(void **)&_hx_dummy;
	::hx::Static(__mClass) = new ::hx::Class_obj();
	__mClass->mName = HX_("haxe.crypto.BaseCode",83,c2,f9,1c);
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &BaseCode_obj::__GetStatic;
	__mClass->mSetStaticField = &::hx::Class_obj::SetNoStaticField;
	__mClass->mStatics = ::hx::Class_obj::dupFunctions(BaseCode_obj_sStaticFields);
	__mClass->mMembers = ::hx::Class_obj::dupFunctions(BaseCode_obj_sMemberFields);
	__mClass->mCanCast = ::hx::TCanCast< BaseCode_obj >;
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = BaseCode_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = BaseCode_obj_sStaticStorageInfo;
#endif
	::hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

} // end namespace haxe
} // end namespace crypto
