// Generated by Haxe 4.3.7
#include <hxcpp.h>

#ifndef INCLUDED_Reflect
#include <Reflect.h>
#endif
#ifndef INCLUDED_Std
#include <Std.h>
#endif
#ifndef INCLUDED_StringBuf
#include <StringBuf.h>
#endif
#ifndef INCLUDED_haxe_format_JsonParser
#include <haxe/format/JsonParser.h>
#endif

namespace haxe{
namespace format{

void JsonParser_obj::__construct(::String str){
	this->str = str;
	this->pos = 0;
}

Dynamic JsonParser_obj::__CreateEmpty() { return new JsonParser_obj; }

void *JsonParser_obj::_hx_vtable = 0;

Dynamic JsonParser_obj::__Create(::hx::DynamicArray inArgs)
{
	::hx::ObjectPtr< JsonParser_obj > _hx_result = new JsonParser_obj();
	_hx_result->__construct(inArgs[0]);
	return _hx_result;
}

bool JsonParser_obj::_hx_isInstanceOf(int inClassId) {
	return inClassId==(int)0x00000001 || inClassId==(int)0x0ae51690;
}

 ::Dynamic JsonParser_obj::doParse(){
	 ::Dynamic result = this->parseRec();
	int c;
	while(true){
		c = this->str.cca(this->pos++);
		if (!((c != 0))) {
			goto _hx_goto_0;
		}
		switch((int)(c)){
			case (int)9: case (int)10: case (int)13: case (int)32: {
			}
			break;
			default:{
				this->invalidChar();
			}
		}
	}
	_hx_goto_0:;
	return result;
}


HX_DEFINE_DYNAMIC_FUNC0(JsonParser_obj,doParse,return )

 ::Dynamic JsonParser_obj::parseRec(){
	while(true){
		int c = this->str.cca(this->pos++);
		switch((int)(c)){
			case (int)9: case (int)10: case (int)13: case (int)32: {
			}
			break;
			case (int)34: {
				return this->parseString();
			}
			break;
			case (int)45: case (int)48: case (int)49: case (int)50: case (int)51: case (int)52: case (int)53: case (int)54: case (int)55: case (int)56: case (int)57: {
				int c1 = c;
				int start = (this->pos - 1);
				bool minus = (c == 45);
				bool digit = !(minus);
				bool zero = (c == 48);
				bool point = false;
				bool e = false;
				bool pm = false;
				bool end = false;
				do {
					c1 = this->str.cca(this->pos++);
					switch((int)(c1)){
						case (int)43: case (int)45: {
							bool _hx_tmp;
							if (e) {
								_hx_tmp = pm;
							}
							else {
								_hx_tmp = true;
							}
							if (_hx_tmp) {
								this->invalidNumber(start);
							}
							digit = false;
							pm = true;
						}
						break;
						case (int)46: {
							bool _hx_tmp1;
							bool _hx_tmp2;
							if (!(minus)) {
								_hx_tmp2 = point;
							}
							else {
								_hx_tmp2 = true;
							}
							if (!(_hx_tmp2)) {
								_hx_tmp1 = e;
							}
							else {
								_hx_tmp1 = true;
							}
							if (_hx_tmp1) {
								this->invalidNumber(start);
							}
							digit = false;
							point = true;
						}
						break;
						case (int)48: {
							bool _hx_tmp3;
							if (zero) {
								_hx_tmp3 = !(point);
							}
							else {
								_hx_tmp3 = false;
							}
							if (_hx_tmp3) {
								this->invalidNumber(start);
							}
							if (minus) {
								minus = false;
								zero = true;
							}
							digit = true;
						}
						break;
						case (int)49: case (int)50: case (int)51: case (int)52: case (int)53: case (int)54: case (int)55: case (int)56: case (int)57: {
							bool _hx_tmp4;
							if (zero) {
								_hx_tmp4 = !(point);
							}
							else {
								_hx_tmp4 = false;
							}
							if (_hx_tmp4) {
								this->invalidNumber(start);
							}
							if (minus) {
								minus = false;
							}
							digit = true;
							zero = false;
						}
						break;
						case (int)69: case (int)101: {
							bool _hx_tmp5;
							bool _hx_tmp6;
							if (!(minus)) {
								_hx_tmp6 = zero;
							}
							else {
								_hx_tmp6 = true;
							}
							if (!(_hx_tmp6)) {
								_hx_tmp5 = e;
							}
							else {
								_hx_tmp5 = true;
							}
							if (_hx_tmp5) {
								this->invalidNumber(start);
							}
							digit = false;
							e = true;
						}
						break;
						default:{
							if (!(digit)) {
								this->invalidNumber(start);
							}
							this->pos--;
							end = true;
						}
					}
				} while(!(end));
;
				Float f = ::Std_obj::parseFloat(this->str.substr(start,(this->pos - start)));
				if (point) {
					return f;
				}
				else {
					int i = ::Std_obj::_hx_int(f);
					if ((i == f)) {
						return i;
					}
					else {
						return f;
					}
				}
			}
			break;
			case (int)91: {
				::cpp::VirtualArray arr = ::cpp::VirtualArray_obj::__new(0);
				 ::Dynamic comma = null();
				while(true){
					switch((int)(this->str.cca(this->pos++))){
						case (int)9: case (int)10: case (int)13: case (int)32: {
						}
						break;
						case (int)44: {
							if (( (bool)(comma) )) {
								comma = false;
							}
							else {
								this->invalidChar();
							}
						}
						break;
						case (int)93: {
							if (::hx::IsEq( comma,false )) {
								this->invalidChar();
							}
							return arr;
						}
						break;
						default:{
							if (( (bool)(comma) )) {
								this->invalidChar();
							}
							this->pos--;
							arr->push(this->parseRec());
							comma = true;
						}
					}
				}
			}
			break;
			case (int)102: {
				int save = this->pos;
				bool _hx_tmp7;
				bool _hx_tmp8;
				bool _hx_tmp9;
				if ((this->str.cca(this->pos++) == 97)) {
					_hx_tmp9 = (this->str.cca(this->pos++) != 108);
				}
				else {
					_hx_tmp9 = true;
				}
				if (!(_hx_tmp9)) {
					_hx_tmp8 = (this->str.cca(this->pos++) != 115);
				}
				else {
					_hx_tmp8 = true;
				}
				if (!(_hx_tmp8)) {
					_hx_tmp7 = (this->str.cca(this->pos++) != 101);
				}
				else {
					_hx_tmp7 = true;
				}
				if (_hx_tmp7) {
					this->pos = save;
					this->invalidChar();
				}
				return false;
			}
			break;
			case (int)110: {
				int save1 = this->pos;
				bool _hx_tmp10;
				bool _hx_tmp11;
				if ((this->str.cca(this->pos++) == 117)) {
					_hx_tmp11 = (this->str.cca(this->pos++) != 108);
				}
				else {
					_hx_tmp11 = true;
				}
				if (!(_hx_tmp11)) {
					_hx_tmp10 = (this->str.cca(this->pos++) != 108);
				}
				else {
					_hx_tmp10 = true;
				}
				if (_hx_tmp10) {
					this->pos = save1;
					this->invalidChar();
				}
				return null();
			}
			break;
			case (int)116: {
				int save2 = this->pos;
				bool _hx_tmp12;
				bool _hx_tmp13;
				if ((this->str.cca(this->pos++) == 114)) {
					_hx_tmp13 = (this->str.cca(this->pos++) != 117);
				}
				else {
					_hx_tmp13 = true;
				}
				if (!(_hx_tmp13)) {
					_hx_tmp12 = (this->str.cca(this->pos++) != 101);
				}
				else {
					_hx_tmp12 = true;
				}
				if (_hx_tmp12) {
					this->pos = save2;
					this->invalidChar();
				}
				return true;
			}
			break;
			case (int)123: {
				 ::Dynamic obj =  ::Dynamic(::hx::Anon_obj::Create(0));
				::String field = null();
				 ::Dynamic comma1 = null();
				while(true){
					switch((int)(this->str.cca(this->pos++))){
						case (int)9: case (int)10: case (int)13: case (int)32: {
						}
						break;
						case (int)34: {
							bool _hx_tmp14;
							if (::hx::IsNull( field )) {
								_hx_tmp14 = ( (bool)(comma1) );
							}
							else {
								_hx_tmp14 = true;
							}
							if (_hx_tmp14) {
								this->invalidChar();
							}
							field = this->parseString();
						}
						break;
						case (int)44: {
							if (( (bool)(comma1) )) {
								comma1 = false;
							}
							else {
								this->invalidChar();
							}
						}
						break;
						case (int)58: {
							if (::hx::IsNull( field )) {
								this->invalidChar();
							}
							::Reflect_obj::setField(obj,field,this->parseRec());
							field = null();
							comma1 = true;
						}
						break;
						case (int)125: {
							bool _hx_tmp15;
							if (::hx::IsNull( field )) {
								_hx_tmp15 = ::hx::IsEq( comma1,false );
							}
							else {
								_hx_tmp15 = true;
							}
							if (_hx_tmp15) {
								this->invalidChar();
							}
							return obj;
						}
						break;
						default:{
							this->invalidChar();
						}
					}
				}
			}
			break;
			default:{
				this->invalidChar();
			}
		}
	}
	return null();
}


HX_DEFINE_DYNAMIC_FUNC0(JsonParser_obj,parseRec,return )

::String JsonParser_obj::parseString(){
            	HX_JUST_GC_STACKFRAME
	int start = this->pos;
	 ::StringBuf buf = null();
	int prev = -1;
	while(true){
		int c = this->str.cca(this->pos++);
		if ((c == 34)) {
			goto _hx_goto_5;
		}
		if ((c == 92)) {
			if (::hx::IsNull( buf )) {
				buf =  ::StringBuf_obj::__alloc( HX_CTX );
			}
			{
				::String s = this->str;
				 ::Dynamic len = ((this->pos - start) - 1);
				if (::hx::IsNotNull( buf->charBuf )) {
					buf->flush();
				}
				if (::hx::IsNull( buf->b )) {
					buf->b = ::Array_obj< ::String >::__new(1)->init(0,s.substr(start,len));
				}
				else {
					::Array< ::String > buf1 = buf->b;
					buf1->push(s.substr(start,len));
				}
			}
			c = this->str.cca(this->pos++);
			bool _hx_tmp;
			if ((c != 117)) {
				_hx_tmp = (prev != -1);
			}
			else {
				_hx_tmp = false;
			}
			if (_hx_tmp) {
				{
					::String x = ::String::fromCharCode(65533);
					if (::hx::IsNotNull( buf->charBuf )) {
						buf->flush();
					}
					if (::hx::IsNull( buf->b )) {
						buf->b = ::Array_obj< ::String >::__new(1)->init(0,::Std_obj::string(x));
					}
					else {
						::Array< ::String > buf2 = buf->b;
						buf2->push(::Std_obj::string(x));
					}
				}
				prev = -1;
			}
			switch((int)(c)){
				case (int)34: case (int)47: case (int)92: {
					if ((c >= 127)) {
						::String x1 = ::String::fromCharCode(c);
						if (::hx::IsNotNull( buf->charBuf )) {
							buf->flush();
						}
						if (::hx::IsNull( buf->b )) {
							buf->b = ::Array_obj< ::String >::__new(1)->init(0,::Std_obj::string(x1));
						}
						else {
							::Array< ::String > buf3 = buf->b;
							buf3->push(::Std_obj::string(x1));
						}
					}
					else {
						if (::hx::IsNull( buf->charBuf )) {
							buf->charBuf = ::Array_obj< char >::__new();
						}
						buf->charBuf->push(c);
					}
				}
				break;
				case (int)98: {
					if (::hx::IsNull( buf->charBuf )) {
						buf->charBuf = ::Array_obj< char >::__new();
					}
					buf->charBuf->push(8);
				}
				break;
				case (int)102: {
					if (::hx::IsNull( buf->charBuf )) {
						buf->charBuf = ::Array_obj< char >::__new();
					}
					buf->charBuf->push(12);
				}
				break;
				case (int)110: {
					if (::hx::IsNull( buf->charBuf )) {
						buf->charBuf = ::Array_obj< char >::__new();
					}
					buf->charBuf->push(10);
				}
				break;
				case (int)114: {
					if (::hx::IsNull( buf->charBuf )) {
						buf->charBuf = ::Array_obj< char >::__new();
					}
					buf->charBuf->push(13);
				}
				break;
				case (int)116: {
					if (::hx::IsNull( buf->charBuf )) {
						buf->charBuf = ::Array_obj< char >::__new();
					}
					buf->charBuf->push(9);
				}
				break;
				case (int)117: {
					int uc = ( (int)(::Std_obj::parseInt((HX_("0x",48,2a,00,00) + this->str.substr(this->pos,4)))) );
					this->pos = (this->pos + 4);
					if ((prev != -1)) {
						bool _hx_tmp1;
						if ((uc >= 56320)) {
							_hx_tmp1 = (uc > 57343);
						}
						else {
							_hx_tmp1 = true;
						}
						if (_hx_tmp1) {
							{
								::String x2 = ::String::fromCharCode(65533);
								if (::hx::IsNotNull( buf->charBuf )) {
									buf->flush();
								}
								if (::hx::IsNull( buf->b )) {
									buf->b = ::Array_obj< ::String >::__new(1)->init(0,::Std_obj::string(x2));
								}
								else {
									::Array< ::String > buf4 = buf->b;
									buf4->push(::Std_obj::string(x2));
								}
							}
							prev = -1;
						}
						else {
							{
								int c1 = ((((prev - 55296) << 10) + (uc - 56320)) + 65536);
								if ((c1 >= 127)) {
									::String x3 = ::String::fromCharCode(c1);
									if (::hx::IsNotNull( buf->charBuf )) {
										buf->flush();
									}
									if (::hx::IsNull( buf->b )) {
										buf->b = ::Array_obj< ::String >::__new(1)->init(0,::Std_obj::string(x3));
									}
									else {
										::Array< ::String > buf5 = buf->b;
										buf5->push(::Std_obj::string(x3));
									}
								}
								else {
									if (::hx::IsNull( buf->charBuf )) {
										buf->charBuf = ::Array_obj< char >::__new();
									}
									buf->charBuf->push(c1);
								}
							}
							prev = -1;
						}
					}
					else {
						bool _hx_tmp2;
						if ((uc >= 55296)) {
							_hx_tmp2 = (uc <= 56319);
						}
						else {
							_hx_tmp2 = false;
						}
						if (_hx_tmp2) {
							prev = uc;
						}
						else {
							if ((uc >= 127)) {
								::String x4 = ::String::fromCharCode(uc);
								if (::hx::IsNotNull( buf->charBuf )) {
									buf->flush();
								}
								if (::hx::IsNull( buf->b )) {
									buf->b = ::Array_obj< ::String >::__new(1)->init(0,::Std_obj::string(x4));
								}
								else {
									::Array< ::String > buf6 = buf->b;
									buf6->push(::Std_obj::string(x4));
								}
							}
							else {
								if (::hx::IsNull( buf->charBuf )) {
									buf->charBuf = ::Array_obj< char >::__new();
								}
								buf->charBuf->push(uc);
							}
						}
					}
				}
				break;
				default:{
					HX_STACK_DO_THROW((((HX_("Invalid escape sequence \\",73,af,f7,b2) + ::String::fromCharCode(c)) + HX_(" at position ",0a,c2,01,e0)) + (this->pos - 1)));
				}
			}
			start = this->pos;
		}
		else {
			if ((c == 0)) {
				HX_STACK_DO_THROW(HX_("Unclosed string",ac,02,ef,ea));
			}
		}
	}
	_hx_goto_5:;
	if ((prev != -1)) {
		::String x5 = ::String::fromCharCode(65533);
		if (::hx::IsNotNull( buf->charBuf )) {
			buf->flush();
		}
		if (::hx::IsNull( buf->b )) {
			buf->b = ::Array_obj< ::String >::__new(1)->init(0,::Std_obj::string(x5));
		}
		else {
			::Array< ::String > buf7 = buf->b;
			buf7->push(::Std_obj::string(x5));
		}
	}
	if (::hx::IsNull( buf )) {
		return this->str.substr(start,((this->pos - start) - 1));
	}
	else {
		{
			::String s1 = this->str;
			 ::Dynamic len1 = ((this->pos - start) - 1);
			if (::hx::IsNotNull( buf->charBuf )) {
				buf->flush();
			}
			if (::hx::IsNull( buf->b )) {
				buf->b = ::Array_obj< ::String >::__new(1)->init(0,s1.substr(start,len1));
			}
			else {
				::Array< ::String > buf8 = buf->b;
				buf8->push(s1.substr(start,len1));
			}
		}
		return buf->toString();
	}
	return null();
}


HX_DEFINE_DYNAMIC_FUNC0(JsonParser_obj,parseString,return )

 ::Dynamic JsonParser_obj::parseNumber(int c){
	int start = (this->pos - 1);
	bool minus = (c == 45);
	bool digit = !(minus);
	bool zero = (c == 48);
	bool point = false;
	bool e = false;
	bool pm = false;
	bool end = false;
	do {
		c = this->str.cca(this->pos++);
		switch((int)(c)){
			case (int)43: case (int)45: {
				bool _hx_tmp;
				if (e) {
					_hx_tmp = pm;
				}
				else {
					_hx_tmp = true;
				}
				if (_hx_tmp) {
					this->invalidNumber(start);
				}
				digit = false;
				pm = true;
			}
			break;
			case (int)46: {
				bool _hx_tmp1;
				bool _hx_tmp2;
				if (!(minus)) {
					_hx_tmp2 = point;
				}
				else {
					_hx_tmp2 = true;
				}
				if (!(_hx_tmp2)) {
					_hx_tmp1 = e;
				}
				else {
					_hx_tmp1 = true;
				}
				if (_hx_tmp1) {
					this->invalidNumber(start);
				}
				digit = false;
				point = true;
			}
			break;
			case (int)48: {
				bool _hx_tmp3;
				if (zero) {
					_hx_tmp3 = !(point);
				}
				else {
					_hx_tmp3 = false;
				}
				if (_hx_tmp3) {
					this->invalidNumber(start);
				}
				if (minus) {
					minus = false;
					zero = true;
				}
				digit = true;
			}
			break;
			case (int)49: case (int)50: case (int)51: case (int)52: case (int)53: case (int)54: case (int)55: case (int)56: case (int)57: {
				bool _hx_tmp4;
				if (zero) {
					_hx_tmp4 = !(point);
				}
				else {
					_hx_tmp4 = false;
				}
				if (_hx_tmp4) {
					this->invalidNumber(start);
				}
				if (minus) {
					minus = false;
				}
				digit = true;
				zero = false;
			}
			break;
			case (int)69: case (int)101: {
				bool _hx_tmp5;
				bool _hx_tmp6;
				if (!(minus)) {
					_hx_tmp6 = zero;
				}
				else {
					_hx_tmp6 = true;
				}
				if (!(_hx_tmp6)) {
					_hx_tmp5 = e;
				}
				else {
					_hx_tmp5 = true;
				}
				if (_hx_tmp5) {
					this->invalidNumber(start);
				}
				digit = false;
				e = true;
			}
			break;
			default:{
				if (!(digit)) {
					this->invalidNumber(start);
				}
				this->pos--;
				end = true;
			}
		}
	} while(!(end));
;
	Float f = ::Std_obj::parseFloat(this->str.substr(start,(this->pos - start)));
	if (point) {
		return f;
	}
	else {
		int i = ::Std_obj::_hx_int(f);
		if ((i == f)) {
			return i;
		}
		else {
			return f;
		}
	}
	return null();
}


HX_DEFINE_DYNAMIC_FUNC1(JsonParser_obj,parseNumber,return )

int JsonParser_obj::nextChar(){
	return this->str.cca(this->pos++);
}


HX_DEFINE_DYNAMIC_FUNC0(JsonParser_obj,nextChar,return )

void JsonParser_obj::invalidChar(){
	this->pos--;
	::String _hx_tmp = ((HX_("Invalid char ",81,66,ec,29) + this->str.cca(this->pos)) + HX_(" at position ",0a,c2,01,e0));
	HX_STACK_DO_THROW((_hx_tmp + this->pos));
}


HX_DEFINE_DYNAMIC_FUNC0(JsonParser_obj,invalidChar,(void))

void JsonParser_obj::invalidNumber(int start){
	HX_STACK_DO_THROW((((HX_("Invalid number at position ",d8,9d,6f,13) + start) + HX_(": ",a6,32,00,00)) + this->str.substr(start,(this->pos - start))));
}


HX_DEFINE_DYNAMIC_FUNC1(JsonParser_obj,invalidNumber,(void))

 ::Dynamic JsonParser_obj::parse(::String str){
            	HX_JUST_GC_STACKFRAME
	return  ::haxe::format::JsonParser_obj::__alloc( HX_CTX ,str)->doParse();
}


STATIC_HX_DEFINE_DYNAMIC_FUNC1(JsonParser_obj,parse,return )


::hx::ObjectPtr< JsonParser_obj > JsonParser_obj::__new(::String str) {
	::hx::ObjectPtr< JsonParser_obj > __this = new JsonParser_obj();
	__this->__construct(str);
	return __this;
}

::hx::ObjectPtr< JsonParser_obj > JsonParser_obj::__alloc(::hx::Ctx *_hx_ctx,::String str) {
	JsonParser_obj *__this = (JsonParser_obj*)(::hx::Ctx::alloc(_hx_ctx, sizeof(JsonParser_obj), true, "haxe.format.JsonParser"));
	*(void **)__this = JsonParser_obj::_hx_vtable;
	__this->__construct(str);
	return __this;
}

JsonParser_obj::JsonParser_obj()
{
}

void JsonParser_obj::__Mark(HX_MARK_PARAMS)
{
	HX_MARK_BEGIN_CLASS(JsonParser);
	HX_MARK_MEMBER_NAME(str,"str");
	HX_MARK_MEMBER_NAME(pos,"pos");
	HX_MARK_END_CLASS();
}

void JsonParser_obj::__Visit(HX_VISIT_PARAMS)
{
	HX_VISIT_MEMBER_NAME(str,"str");
	HX_VISIT_MEMBER_NAME(pos,"pos");
}

::hx::Val JsonParser_obj::__Field(const ::String &inName,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 3:
		if (HX_FIELD_EQ(inName,"str") ) { return ::hx::Val( str ); }
		if (HX_FIELD_EQ(inName,"pos") ) { return ::hx::Val( pos ); }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"doParse") ) { return ::hx::Val( doParse_dyn() ); }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"parseRec") ) { return ::hx::Val( parseRec_dyn() ); }
		if (HX_FIELD_EQ(inName,"nextChar") ) { return ::hx::Val( nextChar_dyn() ); }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"parseString") ) { return ::hx::Val( parseString_dyn() ); }
		if (HX_FIELD_EQ(inName,"parseNumber") ) { return ::hx::Val( parseNumber_dyn() ); }
		if (HX_FIELD_EQ(inName,"invalidChar") ) { return ::hx::Val( invalidChar_dyn() ); }
		break;
	case 13:
		if (HX_FIELD_EQ(inName,"invalidNumber") ) { return ::hx::Val( invalidNumber_dyn() ); }
	}
	return super::__Field(inName,inCallProp);
}

bool JsonParser_obj::__GetStatic(const ::String &inName, Dynamic &outValue, ::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 5:
		if (HX_FIELD_EQ(inName,"parse") ) { outValue = parse_dyn(); return true; }
	}
	return false;
}

::hx::Val JsonParser_obj::__SetField(const ::String &inName,const ::hx::Val &inValue,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 3:
		if (HX_FIELD_EQ(inName,"str") ) { str=inValue.Cast< ::String >(); return inValue; }
		if (HX_FIELD_EQ(inName,"pos") ) { pos=inValue.Cast< int >(); return inValue; }
	}
	return super::__SetField(inName,inValue,inCallProp);
}

void JsonParser_obj::__GetFields(Array< ::String> &outFields)
{
	outFields->push(HX_("str",b1,a8,57,00));
	outFields->push(HX_("pos",94,5d,55,00));
	super::__GetFields(outFields);
};

#ifdef HXCPP_SCRIPTABLE
static ::hx::StorageInfo JsonParser_obj_sMemberStorageInfo[] = {
	{::hx::fsString,(int)offsetof(JsonParser_obj,str),HX_("str",b1,a8,57,00)},
	{::hx::fsInt,(int)offsetof(JsonParser_obj,pos),HX_("pos",94,5d,55,00)},
	{ ::hx::fsUnknown, 0, null()}
};
static ::hx::StaticInfo *JsonParser_obj_sStaticStorageInfo = 0;
#endif

static ::String JsonParser_obj_sMemberFields[] = {
	HX_("str",b1,a8,57,00),
	HX_("pos",94,5d,55,00),
	HX_("doParse",a8,70,82,f0),
	HX_("parseRec",dd,e2,78,d6),
	HX_("parseString",64,d5,6c,8c),
	HX_("parseNumber",5c,33,b7,1c),
	HX_("nextChar",69,05,8c,ed),
	HX_("invalidChar",6d,ad,ce,a9),
	HX_("invalidNumber",20,e9,eb,a6),
	::String(null()) };

::hx::Class JsonParser_obj::__mClass;

static ::String JsonParser_obj_sStaticFields[] = {
	HX_("parse",33,90,55,bd),
	::String(null())
};

void JsonParser_obj::__register()
{
	JsonParser_obj _hx_dummy;
	JsonParser_obj::_hx_vtable = *(void **)&_hx_dummy;
	::hx::Static(__mClass) = new ::hx::Class_obj();
	__mClass->mName = HX_("haxe.format.JsonParser",d6,2a,bf,29);
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &JsonParser_obj::__GetStatic;
	__mClass->mSetStaticField = &::hx::Class_obj::SetNoStaticField;
	__mClass->mStatics = ::hx::Class_obj::dupFunctions(JsonParser_obj_sStaticFields);
	__mClass->mMembers = ::hx::Class_obj::dupFunctions(JsonParser_obj_sMemberFields);
	__mClass->mCanCast = ::hx::TCanCast< JsonParser_obj >;
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = JsonParser_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = JsonParser_obj_sStaticStorageInfo;
#endif
	::hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

} // end namespace haxe
} // end namespace format
