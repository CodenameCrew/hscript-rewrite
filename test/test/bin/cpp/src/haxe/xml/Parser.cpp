// Generated by Haxe 4.3.7
#include <hxcpp.h>

#ifndef INCLUDED_Std
#include <Std.h>
#endif
#ifndef INCLUDED_StringBuf
#include <StringBuf.h>
#endif
#ifndef INCLUDED_Xml
#include <Xml.h>
#endif
#ifndef INCLUDED__Xml_XmlType_Impl_
#include <_Xml/XmlType_Impl_.h>
#endif
#ifndef INCLUDED_haxe_IMap
#include <haxe/IMap.h>
#endif
#ifndef INCLUDED_haxe_ds_StringMap
#include <haxe/ds/StringMap.h>
#endif
#ifndef INCLUDED_haxe_xml_Parser
#include <haxe/xml/Parser.h>
#endif
#ifndef INCLUDED_haxe_xml_XmlParserException
#include <haxe/xml/XmlParserException.h>
#endif

namespace haxe{
namespace xml{

void Parser_obj::__construct() { }

Dynamic Parser_obj::__CreateEmpty() { return new Parser_obj; }

void *Parser_obj::_hx_vtable = 0;

Dynamic Parser_obj::__Create(::hx::DynamicArray inArgs)
{
	::hx::ObjectPtr< Parser_obj > _hx_result = new Parser_obj();
	_hx_result->__construct();
	return _hx_result;
}

bool Parser_obj::_hx_isInstanceOf(int inClassId) {
	return inClassId==(int)0x00000001 || inClassId==(int)0x1c6f1730;
}

 ::haxe::ds::StringMap Parser_obj::escapes;

 ::Xml Parser_obj::parse(::String str,::hx::Null< bool >  __o_strict){
	bool strict = __o_strict.Default(false);
	 ::Xml doc = ::Xml_obj::createDocument();
	::haxe::xml::Parser_obj::doParse(str,strict,0,doc);
	return doc;
}


STATIC_HX_DEFINE_DYNAMIC_FUNC2(Parser_obj,parse,return )

int Parser_obj::doParse(::String str,bool strict,::hx::Null< int >  __o_p, ::Xml parent){
	int p = __o_p.Default(0);
            	HX_JUST_GC_STACKFRAME
	 ::Xml xml = null();
	int state = 1;
	int next = 1;
	::String aname = null();
	int start = 0;
	int nsubs = 0;
	int nbrackets = 0;
	 ::StringBuf buf =  ::StringBuf_obj::__alloc( HX_CTX );
	int escapeNext = 1;
	int attrValQuote = -1;
	while((p < str.length)){
		int c = str.cca(p);
		switch((int)(state)){
			case (int)0: {
				switch((int)(c)){
					case (int)9: case (int)10: case (int)13: case (int)32: {
					}
					break;
					default:{
						state = next;
						continue;
					}
				}
			}
			break;
			case (int)1: {
				if ((c == 60)) {
					state = 0;
					next = 2;
				}
				else {
					start = p;
					state = 13;
					continue;
				}
			}
			break;
			case (int)2: {
				switch((int)(c)){
					case (int)33: {
						if ((str.cca((p + 1)) == 91)) {
							p = (p + 2);
							if ((str.substr(p,6).toUpperCase() != HX_("CDATA[",ce,73,5f,1c))) {
								HX_STACK_DO_THROW( ::haxe::xml::XmlParserException_obj::__alloc( HX_CTX ,HX_("Expected <![CDATA[",1c,11,1f,2d),str,p));
							}
							p = (p + 5);
							state = 17;
							start = (p + 1);
						}
						else {
							bool _hx_tmp;
							if ((str.cca((p + 1)) != 68)) {
								_hx_tmp = (str.cca((p + 1)) == 100);
							}
							else {
								_hx_tmp = true;
							}
							if (_hx_tmp) {
								if ((str.substr((p + 2),6).toUpperCase() != HX_("OCTYPE",ce,19,d4,61))) {
									HX_STACK_DO_THROW( ::haxe::xml::XmlParserException_obj::__alloc( HX_CTX ,HX_("Expected <!DOCTYPE",c5,0b,26,b6),str,p));
								}
								p = (p + 8);
								state = 16;
								start = (p + 1);
							}
							else {
								bool _hx_tmp1;
								if ((str.cca((p + 1)) == 45)) {
									_hx_tmp1 = (str.cca((p + 2)) != 45);
								}
								else {
									_hx_tmp1 = true;
								}
								if (_hx_tmp1) {
									HX_STACK_DO_THROW( ::haxe::xml::XmlParserException_obj::__alloc( HX_CTX ,HX_("Expected <!--",8d,3d,c1,53),str,p));
								}
								else {
									p = (p + 2);
									state = 15;
									start = (p + 1);
								}
							}
						}
					}
					break;
					case (int)47: {
						if (::hx::IsNull( parent )) {
							HX_STACK_DO_THROW( ::haxe::xml::XmlParserException_obj::__alloc( HX_CTX ,HX_("Expected node name",a1,85,63,3f),str,p));
						}
						start = (p + 1);
						state = 0;
						next = 10;
					}
					break;
					case (int)63: {
						state = 14;
						start = p;
					}
					break;
					default:{
						state = 3;
						start = p;
						continue;
					}
				}
			}
			break;
			case (int)3: {
				bool _hx_tmp2;
				bool _hx_tmp3;
				bool _hx_tmp4;
				bool _hx_tmp5;
				bool _hx_tmp6;
				bool _hx_tmp7;
				bool _hx_tmp8;
				if ((c >= 97)) {
					_hx_tmp8 = (c <= 122);
				}
				else {
					_hx_tmp8 = false;
				}
				if (!(_hx_tmp8)) {
					if ((c >= 65)) {
						_hx_tmp7 = (c <= 90);
					}
					else {
						_hx_tmp7 = false;
					}
				}
				else {
					_hx_tmp7 = true;
				}
				if (!(_hx_tmp7)) {
					if ((c >= 48)) {
						_hx_tmp6 = (c <= 57);
					}
					else {
						_hx_tmp6 = false;
					}
				}
				else {
					_hx_tmp6 = true;
				}
				if (!(_hx_tmp6)) {
					_hx_tmp5 = (c == 58);
				}
				else {
					_hx_tmp5 = true;
				}
				if (!(_hx_tmp5)) {
					_hx_tmp4 = (c == 46);
				}
				else {
					_hx_tmp4 = true;
				}
				if (!(_hx_tmp4)) {
					_hx_tmp3 = (c == 95);
				}
				else {
					_hx_tmp3 = true;
				}
				if (!(_hx_tmp3)) {
					_hx_tmp2 = (c == 45);
				}
				else {
					_hx_tmp2 = true;
				}
				if (!(_hx_tmp2)) {
					if ((p == start)) {
						HX_STACK_DO_THROW( ::haxe::xml::XmlParserException_obj::__alloc( HX_CTX ,HX_("Expected node name",a1,85,63,3f),str,p));
					}
					xml = ::Xml_obj::createElement(str.substr(start,(p - start)));
					{
						parent->addChild(xml);
						nsubs = (nsubs + 1);
					}
					state = 0;
					next = 4;
					continue;
				}
			}
			break;
			case (int)4: {
				switch((int)(c)){
					case (int)47: {
						state = 11;
					}
					break;
					case (int)62: {
						state = 9;
					}
					break;
					default:{
						state = 5;
						start = p;
						continue;
					}
				}
			}
			break;
			case (int)5: {
				bool _hx_tmp9;
				bool _hx_tmp10;
				bool _hx_tmp11;
				bool _hx_tmp12;
				bool _hx_tmp13;
				bool _hx_tmp14;
				bool _hx_tmp15;
				if ((c >= 97)) {
					_hx_tmp15 = (c <= 122);
				}
				else {
					_hx_tmp15 = false;
				}
				if (!(_hx_tmp15)) {
					if ((c >= 65)) {
						_hx_tmp14 = (c <= 90);
					}
					else {
						_hx_tmp14 = false;
					}
				}
				else {
					_hx_tmp14 = true;
				}
				if (!(_hx_tmp14)) {
					if ((c >= 48)) {
						_hx_tmp13 = (c <= 57);
					}
					else {
						_hx_tmp13 = false;
					}
				}
				else {
					_hx_tmp13 = true;
				}
				if (!(_hx_tmp13)) {
					_hx_tmp12 = (c == 58);
				}
				else {
					_hx_tmp12 = true;
				}
				if (!(_hx_tmp12)) {
					_hx_tmp11 = (c == 46);
				}
				else {
					_hx_tmp11 = true;
				}
				if (!(_hx_tmp11)) {
					_hx_tmp10 = (c == 95);
				}
				else {
					_hx_tmp10 = true;
				}
				if (!(_hx_tmp10)) {
					_hx_tmp9 = (c == 45);
				}
				else {
					_hx_tmp9 = true;
				}
				if (!(_hx_tmp9)) {
					if ((start == p)) {
						HX_STACK_DO_THROW( ::haxe::xml::XmlParserException_obj::__alloc( HX_CTX ,HX_("Expected attribute name",57,65,2b,54),str,p));
					}
					::String tmp = str.substr(start,(p - start));
					aname = tmp;
					if (xml->exists(tmp)) {
						HX_STACK_DO_THROW( ::haxe::xml::XmlParserException_obj::__alloc( HX_CTX ,((HX_("Duplicate attribute [",22,75,cb,05) + tmp) + HX_("]",5d,00,00,00)),str,p));
					}
					state = 0;
					next = 6;
					continue;
				}
			}
			break;
			case (int)6: {
				if ((c == 61)) {
					state = 0;
					next = 7;
				}
				else {
					HX_STACK_DO_THROW( ::haxe::xml::XmlParserException_obj::__alloc( HX_CTX ,HX_("Expected =",b5,dc,23,c6),str,p));
				}
			}
			break;
			case (int)7: {
				switch((int)(c)){
					case (int)34: case (int)39: {
						buf =  ::StringBuf_obj::__alloc( HX_CTX );
						state = 8;
						start = (p + 1);
						attrValQuote = c;
					}
					break;
					default:{
						HX_STACK_DO_THROW( ::haxe::xml::XmlParserException_obj::__alloc( HX_CTX ,HX_("Expected \"",9a,dc,23,c6),str,p));
					}
				}
			}
			break;
			case (int)8: {
				switch((int)(c)){
					case (int)38: {
						{
							 ::Dynamic len = (p - start);
							if (::hx::IsNotNull( buf->charBuf )) {
								buf->flush();
							}
							if (::hx::IsNull( buf->b )) {
								buf->b = ::Array_obj< ::String >::__new(1)->init(0,str.substr(start,len));
							}
							else {
								::Array< ::String > buf1 = buf->b;
								buf1->push(str.substr(start,len));
							}
						}
						state = 18;
						escapeNext = 8;
						start = (p + 1);
					}
					break;
					case (int)60: case (int)62: {
						if (strict) {
							HX_STACK_DO_THROW( ::haxe::xml::XmlParserException_obj::__alloc( HX_CTX ,((HX_("Invalid unescaped ",ff,da,cb,cc) + ::String::fromCharCode(c)) + HX_(" in attribute value",52,5a,ca,13)),str,p));
						}
						else {
							if ((c == attrValQuote)) {
								{
									 ::Dynamic len1 = (p - start);
									if (::hx::IsNotNull( buf->charBuf )) {
										buf->flush();
									}
									if (::hx::IsNull( buf->b )) {
										buf->b = ::Array_obj< ::String >::__new(1)->init(0,str.substr(start,len1));
									}
									else {
										::Array< ::String > buf2 = buf->b;
										buf2->push(str.substr(start,len1));
									}
								}
								::String val = buf->toString();
								buf =  ::StringBuf_obj::__alloc( HX_CTX );
								xml->set(aname,val);
								state = 0;
								next = 4;
							}
						}
					}
					break;
					default:{
						if ((c == attrValQuote)) {
							{
								 ::Dynamic len2 = (p - start);
								if (::hx::IsNotNull( buf->charBuf )) {
									buf->flush();
								}
								if (::hx::IsNull( buf->b )) {
									buf->b = ::Array_obj< ::String >::__new(1)->init(0,str.substr(start,len2));
								}
								else {
									::Array< ::String > buf3 = buf->b;
									buf3->push(str.substr(start,len2));
								}
							}
							::String val1 = buf->toString();
							buf =  ::StringBuf_obj::__alloc( HX_CTX );
							xml->set(aname,val1);
							state = 0;
							next = 4;
						}
					}
				}
			}
			break;
			case (int)9: {
				p = ::haxe::xml::Parser_obj::doParse(str,strict,p,xml);
				start = p;
				state = 1;
			}
			break;
			case (int)10: {
				bool _hx_tmp16;
				bool _hx_tmp17;
				bool _hx_tmp18;
				bool _hx_tmp19;
				bool _hx_tmp20;
				bool _hx_tmp21;
				bool _hx_tmp22;
				if ((c >= 97)) {
					_hx_tmp22 = (c <= 122);
				}
				else {
					_hx_tmp22 = false;
				}
				if (!(_hx_tmp22)) {
					if ((c >= 65)) {
						_hx_tmp21 = (c <= 90);
					}
					else {
						_hx_tmp21 = false;
					}
				}
				else {
					_hx_tmp21 = true;
				}
				if (!(_hx_tmp21)) {
					if ((c >= 48)) {
						_hx_tmp20 = (c <= 57);
					}
					else {
						_hx_tmp20 = false;
					}
				}
				else {
					_hx_tmp20 = true;
				}
				if (!(_hx_tmp20)) {
					_hx_tmp19 = (c == 58);
				}
				else {
					_hx_tmp19 = true;
				}
				if (!(_hx_tmp19)) {
					_hx_tmp18 = (c == 46);
				}
				else {
					_hx_tmp18 = true;
				}
				if (!(_hx_tmp18)) {
					_hx_tmp17 = (c == 95);
				}
				else {
					_hx_tmp17 = true;
				}
				if (!(_hx_tmp17)) {
					_hx_tmp16 = (c == 45);
				}
				else {
					_hx_tmp16 = true;
				}
				if (!(_hx_tmp16)) {
					if ((start == p)) {
						HX_STACK_DO_THROW( ::haxe::xml::XmlParserException_obj::__alloc( HX_CTX ,HX_("Expected node name",a1,85,63,3f),str,p));
					}
					::String v = str.substr(start,(p - start));
					bool _hx_tmp23;
					if (::hx::IsNotNull( parent )) {
						_hx_tmp23 = (parent->nodeType != 0);
					}
					else {
						_hx_tmp23 = true;
					}
					if (_hx_tmp23) {
						HX_STACK_DO_THROW( ::haxe::xml::XmlParserException_obj::__alloc( HX_CTX ,((HX_("Unexpected </",42,6f,35,1e) + v) + HX_(">, tag is not open",35,30,75,b8)),str,p));
					}
					if ((parent->nodeType != ::Xml_obj::Element)) {
						HX_STACK_DO_THROW((HX_("Bad node type, expected Element but found ",d8,90,8b,bb) + ::_Xml::XmlType_Impl__obj::toString(parent->nodeType)));
					}
					if ((v != parent->nodeName)) {
						if ((parent->nodeType != ::Xml_obj::Element)) {
							HX_STACK_DO_THROW((HX_("Bad node type, expected Element but found ",d8,90,8b,bb) + ::_Xml::XmlType_Impl__obj::toString(parent->nodeType)));
						}
						HX_STACK_DO_THROW( ::haxe::xml::XmlParserException_obj::__alloc( HX_CTX ,((HX_("Expected </",fb,40,3d,99) + parent->nodeName) + HX_(">",3e,00,00,00)),str,p));
					}
					state = 0;
					next = 12;
					continue;
				}
			}
			break;
			case (int)11: {
				if ((c == 62)) {
					state = 1;
				}
				else {
					HX_STACK_DO_THROW( ::haxe::xml::XmlParserException_obj::__alloc( HX_CTX ,HX_("Expected >",b6,dc,23,c6),str,p));
				}
			}
			break;
			case (int)12: {
				if ((c == 62)) {
					if ((nsubs == 0)) {
						parent->addChild(::Xml_obj::createPCData(HX_("",00,00,00,00)));
					}
					return p;
				}
				else {
					HX_STACK_DO_THROW( ::haxe::xml::XmlParserException_obj::__alloc( HX_CTX ,HX_("Expected >",b6,dc,23,c6),str,p));
				}
			}
			break;
			case (int)13: {
				if ((c == 60)) {
					{
						 ::Dynamic len3 = (p - start);
						if (::hx::IsNotNull( buf->charBuf )) {
							buf->flush();
						}
						if (::hx::IsNull( buf->b )) {
							buf->b = ::Array_obj< ::String >::__new(1)->init(0,str.substr(start,len3));
						}
						else {
							::Array< ::String > buf4 = buf->b;
							buf4->push(str.substr(start,len3));
						}
					}
					 ::Xml child = ::Xml_obj::createPCData(buf->toString());
					buf =  ::StringBuf_obj::__alloc( HX_CTX );
					{
						parent->addChild(child);
						nsubs = (nsubs + 1);
					}
					state = 0;
					next = 2;
				}
				else {
					if ((c == 38)) {
						{
							 ::Dynamic len4 = (p - start);
							if (::hx::IsNotNull( buf->charBuf )) {
								buf->flush();
							}
							if (::hx::IsNull( buf->b )) {
								buf->b = ::Array_obj< ::String >::__new(1)->init(0,str.substr(start,len4));
							}
							else {
								::Array< ::String > buf5 = buf->b;
								buf5->push(str.substr(start,len4));
							}
						}
						state = 18;
						escapeNext = 13;
						start = (p + 1);
					}
				}
			}
			break;
			case (int)14: {
				bool _hx_tmp24;
				if ((c == 63)) {
					_hx_tmp24 = (str.cca((p + 1)) == 62);
				}
				else {
					_hx_tmp24 = false;
				}
				if (_hx_tmp24) {
					p = (p + 1);
					::String str1 = str.substr((start + 1),((p - start) - 2));
					{
						parent->addChild(::Xml_obj::createProcessingInstruction(str1));
						nsubs = (nsubs + 1);
					}
					state = 1;
				}
			}
			break;
			case (int)15: {
				bool _hx_tmp25;
				bool _hx_tmp26;
				if ((c == 45)) {
					_hx_tmp26 = (str.cca((p + 1)) == 45);
				}
				else {
					_hx_tmp26 = false;
				}
				if (_hx_tmp26) {
					_hx_tmp25 = (str.cca((p + 2)) == 62);
				}
				else {
					_hx_tmp25 = false;
				}
				if (_hx_tmp25) {
					{
						parent->addChild(::Xml_obj::createComment(str.substr(start,(p - start))));
						nsubs = (nsubs + 1);
					}
					p = (p + 2);
					state = 1;
				}
			}
			break;
			case (int)16: {
				if ((c == 91)) {
					nbrackets = (nbrackets + 1);
				}
				else {
					if ((c == 93)) {
						nbrackets = (nbrackets - 1);
					}
					else {
						bool _hx_tmp27;
						if ((c == 62)) {
							_hx_tmp27 = (nbrackets == 0);
						}
						else {
							_hx_tmp27 = false;
						}
						if (_hx_tmp27) {
							{
								parent->addChild(::Xml_obj::createDocType(str.substr(start,(p - start))));
								nsubs = (nsubs + 1);
							}
							state = 1;
						}
					}
				}
			}
			break;
			case (int)17: {
				bool _hx_tmp28;
				bool _hx_tmp29;
				if ((c == 93)) {
					_hx_tmp29 = (str.cca((p + 1)) == 93);
				}
				else {
					_hx_tmp29 = false;
				}
				if (_hx_tmp29) {
					_hx_tmp28 = (str.cca((p + 2)) == 62);
				}
				else {
					_hx_tmp28 = false;
				}
				if (_hx_tmp28) {
					 ::Xml child1 = ::Xml_obj::createCData(str.substr(start,(p - start)));
					{
						parent->addChild(child1);
						nsubs = (nsubs + 1);
					}
					p = (p + 2);
					state = 1;
				}
			}
			break;
			case (int)18: {
				if ((c == 59)) {
					::String s = str.substr(start,(p - start));
					if ((s.cca(0) == 35)) {
						 ::Dynamic c1;
						if ((s.cca(1) == 120)) {
							c1 = ::Std_obj::parseInt((HX_("0",30,00,00,00) + s.substr(1,(s.length - 1))));
						}
						else {
							c1 = ::Std_obj::parseInt(s.substr(1,(s.length - 1)));
						}
						{
							int c2 = ( (int)(c1) );
							if ((c2 >= 127)) {
								::String x = ::String::fromCharCode(c2);
								if (::hx::IsNotNull( buf->charBuf )) {
									buf->flush();
								}
								if (::hx::IsNull( buf->b )) {
									buf->b = ::Array_obj< ::String >::__new(1)->init(0,::Std_obj::string(x));
								}
								else {
									::Array< ::String > buf6 = buf->b;
									buf6->push(::Std_obj::string(x));
								}
							}
							else {
								if (::hx::IsNull( buf->charBuf )) {
									buf->charBuf = ::Array_obj< char >::__new();
								}
								buf->charBuf->push(c2);
							}
						}
					}
					else {
						if (!(::haxe::xml::Parser_obj::escapes->exists(s))) {
							if (strict) {
								HX_STACK_DO_THROW( ::haxe::xml::XmlParserException_obj::__alloc( HX_CTX ,(HX_("Undefined entity: ",39,48,f2,48) + s),str,p));
							}
							{
								::String x1 = ((HX_("&",26,00,00,00) + s) + HX_(";",3b,00,00,00));
								if (::hx::IsNotNull( buf->charBuf )) {
									buf->flush();
								}
								if (::hx::IsNull( buf->b )) {
									buf->b = ::Array_obj< ::String >::__new(1)->init(0,::Std_obj::string(x1));
								}
								else {
									::Array< ::String > buf7 = buf->b;
									buf7->push(::Std_obj::string(x1));
								}
							}
						}
						else {
							::String x2 = ::haxe::xml::Parser_obj::escapes->get_string(s);
							if (::hx::IsNotNull( buf->charBuf )) {
								buf->flush();
							}
							if (::hx::IsNull( buf->b )) {
								buf->b = ::Array_obj< ::String >::__new(1)->init(0,::Std_obj::string(x2));
							}
							else {
								::Array< ::String > buf8 = buf->b;
								buf8->push(::Std_obj::string(x2));
							}
						}
					}
					start = (p + 1);
					state = escapeNext;
				}
				else {
					bool _hx_tmp30;
					bool _hx_tmp31;
					bool _hx_tmp32;
					bool _hx_tmp33;
					bool _hx_tmp34;
					bool _hx_tmp35;
					bool _hx_tmp36;
					bool _hx_tmp37;
					if ((c >= 97)) {
						_hx_tmp37 = (c <= 122);
					}
					else {
						_hx_tmp37 = false;
					}
					if (!(_hx_tmp37)) {
						if ((c >= 65)) {
							_hx_tmp36 = (c <= 90);
						}
						else {
							_hx_tmp36 = false;
						}
					}
					else {
						_hx_tmp36 = true;
					}
					if (!(_hx_tmp36)) {
						if ((c >= 48)) {
							_hx_tmp35 = (c <= 57);
						}
						else {
							_hx_tmp35 = false;
						}
					}
					else {
						_hx_tmp35 = true;
					}
					if (!(_hx_tmp35)) {
						_hx_tmp34 = (c == 58);
					}
					else {
						_hx_tmp34 = true;
					}
					if (!(_hx_tmp34)) {
						_hx_tmp33 = (c == 46);
					}
					else {
						_hx_tmp33 = true;
					}
					if (!(_hx_tmp33)) {
						_hx_tmp32 = (c == 95);
					}
					else {
						_hx_tmp32 = true;
					}
					if (!(_hx_tmp32)) {
						_hx_tmp31 = (c == 45);
					}
					else {
						_hx_tmp31 = true;
					}
					if (!(_hx_tmp31)) {
						_hx_tmp30 = (c != 35);
					}
					else {
						_hx_tmp30 = false;
					}
					if (_hx_tmp30) {
						if (strict) {
							HX_STACK_DO_THROW( ::haxe::xml::XmlParserException_obj::__alloc( HX_CTX ,(HX_("Invalid character in entity: ",24,85,11,30) + ::String::fromCharCode(c)),str,p));
						}
						{
							if (::hx::IsNull( buf->charBuf )) {
								buf->charBuf = ::Array_obj< char >::__new();
							}
							buf->charBuf->push(38);
						}
						{
							 ::Dynamic len5 = (p - start);
							if (::hx::IsNotNull( buf->charBuf )) {
								buf->flush();
							}
							if (::hx::IsNull( buf->b )) {
								buf->b = ::Array_obj< ::String >::__new(1)->init(0,str.substr(start,len5));
							}
							else {
								::Array< ::String > buf9 = buf->b;
								buf9->push(str.substr(start,len5));
							}
						}
						p = (p - 1);
						start = (p + 1);
						state = escapeNext;
					}
				}
			}
			break;
		}
		p = (p + 1);
	}
	if ((state == 1)) {
		start = p;
		state = 13;
	}
	if ((state == 13)) {
		if ((parent->nodeType == 0)) {
			if ((parent->nodeType != ::Xml_obj::Element)) {
				HX_STACK_DO_THROW((HX_("Bad node type, expected Element but found ",d8,90,8b,bb) + ::_Xml::XmlType_Impl__obj::toString(parent->nodeType)));
			}
			HX_STACK_DO_THROW( ::haxe::xml::XmlParserException_obj::__alloc( HX_CTX ,((HX_("Unclosed node <",79,04,e1,00) + parent->nodeName) + HX_(">",3e,00,00,00)),str,p));
		}
		bool _hx_tmp38;
		if ((p == start)) {
			_hx_tmp38 = (nsubs == 0);
		}
		else {
			_hx_tmp38 = true;
		}
		if (_hx_tmp38) {
			{
				 ::Dynamic len6 = (p - start);
				if (::hx::IsNotNull( buf->charBuf )) {
					buf->flush();
				}
				if (::hx::IsNull( buf->b )) {
					buf->b = ::Array_obj< ::String >::__new(1)->init(0,str.substr(start,len6));
				}
				else {
					::Array< ::String > buf10 = buf->b;
					buf10->push(str.substr(start,len6));
				}
			}
			parent->addChild(::Xml_obj::createPCData(buf->toString()));
		}
		return p;
	}
	bool _hx_tmp39;
	bool _hx_tmp40;
	if (!(strict)) {
		_hx_tmp40 = (state == 18);
	}
	else {
		_hx_tmp40 = false;
	}
	if (_hx_tmp40) {
		_hx_tmp39 = (escapeNext == 13);
	}
	else {
		_hx_tmp39 = false;
	}
	if (_hx_tmp39) {
		{
			if (::hx::IsNull( buf->charBuf )) {
				buf->charBuf = ::Array_obj< char >::__new();
			}
			buf->charBuf->push(38);
		}
		{
			 ::Dynamic len7 = (p - start);
			if (::hx::IsNotNull( buf->charBuf )) {
				buf->flush();
			}
			if (::hx::IsNull( buf->b )) {
				buf->b = ::Array_obj< ::String >::__new(1)->init(0,str.substr(start,len7));
			}
			else {
				::Array< ::String > buf11 = buf->b;
				buf11->push(str.substr(start,len7));
			}
		}
		parent->addChild(::Xml_obj::createPCData(buf->toString()));
		return p;
	}
	HX_STACK_DO_THROW( ::haxe::xml::XmlParserException_obj::__alloc( HX_CTX ,HX_("Unexpected end",2c,3e,ab,50),str,p));
	return 0;
}


STATIC_HX_DEFINE_DYNAMIC_FUNC4(Parser_obj,doParse,return )

bool Parser_obj::isValidChar(int c){
	bool _hx_tmp;
	bool _hx_tmp1;
	bool _hx_tmp2;
	bool _hx_tmp3;
	bool _hx_tmp4;
	bool _hx_tmp5;
	if ((c >= 97)) {
		_hx_tmp5 = (c <= 122);
	}
	else {
		_hx_tmp5 = false;
	}
	if (!(_hx_tmp5)) {
		if ((c >= 65)) {
			_hx_tmp4 = (c <= 90);
		}
		else {
			_hx_tmp4 = false;
		}
	}
	else {
		_hx_tmp4 = true;
	}
	if (!(_hx_tmp4)) {
		if ((c >= 48)) {
			_hx_tmp3 = (c <= 57);
		}
		else {
			_hx_tmp3 = false;
		}
	}
	else {
		_hx_tmp3 = true;
	}
	if (!(_hx_tmp3)) {
		_hx_tmp2 = (c == 58);
	}
	else {
		_hx_tmp2 = true;
	}
	if (!(_hx_tmp2)) {
		_hx_tmp1 = (c == 46);
	}
	else {
		_hx_tmp1 = true;
	}
	if (!(_hx_tmp1)) {
		_hx_tmp = (c == 95);
	}
	else {
		_hx_tmp = true;
	}
	if (!(_hx_tmp)) {
		return (c == 45);
	}
	else {
		return true;
	}
	return false;
}


STATIC_HX_DEFINE_DYNAMIC_FUNC1(Parser_obj,isValidChar,return )


Parser_obj::Parser_obj()
{
}

bool Parser_obj::__GetStatic(const ::String &inName, Dynamic &outValue, ::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 5:
		if (HX_FIELD_EQ(inName,"parse") ) { outValue = parse_dyn(); return true; }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"escapes") ) { outValue = ( escapes ); return true; }
		if (HX_FIELD_EQ(inName,"doParse") ) { outValue = doParse_dyn(); return true; }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"isValidChar") ) { outValue = isValidChar_dyn(); return true; }
	}
	return false;
}

bool Parser_obj::__SetStatic(const ::String &inName,Dynamic &ioValue,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 7:
		if (HX_FIELD_EQ(inName,"escapes") ) { escapes=ioValue.Cast<  ::haxe::ds::StringMap >(); return true; }
	}
	return false;
}

#ifdef HXCPP_SCRIPTABLE
static ::hx::StorageInfo *Parser_obj_sMemberStorageInfo = 0;
static ::hx::StaticInfo Parser_obj_sStaticStorageInfo[] = {
	{::hx::fsObject /*  ::haxe::ds::StringMap */ ,(void *) &Parser_obj::escapes,HX_("escapes",d2,cd,20,a4)},
	{ ::hx::fsUnknown, 0, null()}
};
#endif

static void Parser_obj_sMarkStatics(HX_MARK_PARAMS) {
	HX_MARK_MEMBER_NAME(Parser_obj::escapes,"escapes");
};

#ifdef HXCPP_VISIT_ALLOCS
static void Parser_obj_sVisitStatics(HX_VISIT_PARAMS) {
	HX_VISIT_MEMBER_NAME(Parser_obj::escapes,"escapes");
};

#endif

::hx::Class Parser_obj::__mClass;

static ::String Parser_obj_sStaticFields[] = {
	HX_("escapes",d2,cd,20,a4),
	HX_("parse",33,90,55,bd),
	HX_("doParse",a8,70,82,f0),
	HX_("isValidChar",a8,e4,15,0d),
	::String(null())
};

void Parser_obj::__register()
{
	Parser_obj _hx_dummy;
	Parser_obj::_hx_vtable = *(void **)&_hx_dummy;
	::hx::Static(__mClass) = new ::hx::Class_obj();
	__mClass->mName = HX_("haxe.xml.Parser",fe,49,90,c4);
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &Parser_obj::__GetStatic;
	__mClass->mSetStaticField = &Parser_obj::__SetStatic;
	__mClass->mMarkFunc = Parser_obj_sMarkStatics;
	__mClass->mStatics = ::hx::Class_obj::dupFunctions(Parser_obj_sStaticFields);
	__mClass->mMembers = ::hx::Class_obj::dupFunctions(0 /* sMemberFields */);
	__mClass->mCanCast = ::hx::TCanCast< Parser_obj >;
#ifdef HXCPP_VISIT_ALLOCS
	__mClass->mVisitFunc = Parser_obj_sVisitStatics;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = Parser_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = Parser_obj_sStaticStorageInfo;
#endif
	::hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

void Parser_obj::__boot()
{
{
	HX_BEGIN_LOCAL_FUNC_S0(::hx::LocalFunc,_hx_Closure_0) HXARGC(0)
	 ::haxe::ds::StringMap _hx_run(){
		HX_JUST_GC_STACKFRAME
		 ::haxe::ds::StringMap h =  ::haxe::ds::StringMap_obj::__alloc( HX_CTX );
		h->set(HX_("lt",88,5e,00,00),HX_("<",3c,00,00,00));
		h->set(HX_("gt",2d,5a,00,00),HX_(">",3e,00,00,00));
		h->set(HX_("amp",04,fa,49,00),HX_("&",26,00,00,00));
		h->set(HX_("quot",09,45,0a,4b),HX_("\"",22,00,00,00));
		h->set(HX_("apos",d3,0f,73,40),HX_("'",27,00,00,00));
		return h;
	}
	HX_END_LOCAL_FUNC0(return)

	escapes = ( ( ::haxe::ds::StringMap)( ::Dynamic(new _hx_Closure_0())()) );
}
}

} // end namespace haxe
} // end namespace xml
