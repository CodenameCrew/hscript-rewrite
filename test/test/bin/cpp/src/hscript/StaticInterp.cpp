// Generated by Haxe 4.3.7
#include <hxcpp.h>

#ifndef INCLUDED_IntIterator
#include <IntIterator.h>
#endif
#ifndef INCLUDED_Reflect
#include <Reflect.h>
#endif
#ifndef INCLUDED_Std
#include <Std.h>
#endif
#ifndef INCLUDED_Type
#include <Type.h>
#endif
#ifndef INCLUDED_haxe_IMap
#include <haxe/IMap.h>
#endif
#ifndef INCLUDED_haxe_ds_BalancedTree
#include <haxe/ds/BalancedTree.h>
#endif
#ifndef INCLUDED_haxe_ds_Either
#include <haxe/ds/Either.h>
#endif
#ifndef INCLUDED_haxe_ds_EnumValueMap
#include <haxe/ds/EnumValueMap.h>
#endif
#ifndef INCLUDED_haxe_ds_IntMap
#include <haxe/ds/IntMap.h>
#endif
#ifndef INCLUDED_haxe_ds_ObjectMap
#include <haxe/ds/ObjectMap.h>
#endif
#ifndef INCLUDED_haxe_ds_StringMap
#include <haxe/ds/StringMap.h>
#endif
#ifndef INCLUDED_hscript_IHScriptCustomBehaviour
#include <hscript/IHScriptCustomBehaviour.h>
#endif
#ifndef INCLUDED_hscript_LConst
#include <hscript/LConst.h>
#endif
#ifndef INCLUDED_hscript_StaticInterp
#include <hscript/StaticInterp.h>
#endif

namespace hscript{

void StaticInterp_obj::__construct() { }

Dynamic StaticInterp_obj::__CreateEmpty() { return new StaticInterp_obj; }

void *StaticInterp_obj::_hx_vtable = 0;

Dynamic StaticInterp_obj::__Create(::hx::DynamicArray inArgs)
{
	::hx::ObjectPtr< StaticInterp_obj > _hx_result = new StaticInterp_obj();
	_hx_result->__construct();
	return _hx_result;
}

bool StaticInterp_obj::_hx_isInstanceOf(int inClassId) {
	return inClassId==(int)0x00000001 || inClassId==(int)0x3139dd2d;
}

 ::haxe::ds::StringMap StaticInterp_obj::staticVariables;

 ::Dynamic StaticInterp_obj::evaluateBinop(unsigned char op, ::Dynamic val1, ::Dynamic val2){
            	HX_JUST_GC_STACKFRAME
	unsigned char _hx_switch_0 = op;
	if (  (_hx_switch_0==( (unsigned char)(0) )) ){
		return (val1 + val2);
		goto _hx_goto_0;
	}
	if (  (_hx_switch_0==( (unsigned char)(1) )) ){
		return (( (Float)(val1) ) - ( (Float)(val2) ));
		goto _hx_goto_0;
	}
	if (  (_hx_switch_0==( (unsigned char)(2) )) ){
		return (( (Float)(val1) ) * ( (Float)(val2) ));
		goto _hx_goto_0;
	}
	if (  (_hx_switch_0==( (unsigned char)(3) )) ){
		return (( (Float)(val1) ) / ( (Float)(val2) ));
		goto _hx_goto_0;
	}
	if (  (_hx_switch_0==( (unsigned char)(4) )) ){
		return ::hx::Mod(val1,val2);
		goto _hx_goto_0;
	}
	if (  (_hx_switch_0==( (unsigned char)(5) )) ){
		return (( (int)(val1) ) & ( (int)(val2) ));
		goto _hx_goto_0;
	}
	if (  (_hx_switch_0==( (unsigned char)(6) )) ){
		return (( (int)(val1) ) | ( (int)(val2) ));
		goto _hx_goto_0;
	}
	if (  (_hx_switch_0==( (unsigned char)(7) )) ){
		return (( (int)(val1) ) ^ ( (int)(val2) ));
		goto _hx_goto_0;
	}
	if (  (_hx_switch_0==( (unsigned char)(8) )) ){
		return (( (int)(val1) ) << ( (int)(val2) ));
		goto _hx_goto_0;
	}
	if (  (_hx_switch_0==( (unsigned char)(9) )) ){
		return (( (int)(val1) ) >> ( (int)(val2) ));
		goto _hx_goto_0;
	}
	if (  (_hx_switch_0==( (unsigned char)(10) )) ){
		return ::hx::UShr(( (int)(val1) ),( (int)(val2) ));
		goto _hx_goto_0;
	}
	if (  (_hx_switch_0==( (unsigned char)(11) )) ){
		return ::hx::IsEq( val1,val2 );
		goto _hx_goto_0;
	}
	if (  (_hx_switch_0==( (unsigned char)(12) )) ){
		return ::hx::IsNotEq( val1,val2 );
		goto _hx_goto_0;
	}
	if (  (_hx_switch_0==( (unsigned char)(13) )) ){
		return ::hx::IsGreaterEq( val1,val2 );
		goto _hx_goto_0;
	}
	if (  (_hx_switch_0==( (unsigned char)(14) )) ){
		return ::hx::IsLessEq( val1,val2 );
		goto _hx_goto_0;
	}
	if (  (_hx_switch_0==( (unsigned char)(15) )) ){
		return ::hx::IsGreater( val1,val2 );
		goto _hx_goto_0;
	}
	if (  (_hx_switch_0==( (unsigned char)(16) )) ){
		return ::hx::IsLess( val1,val2 );
		goto _hx_goto_0;
	}
	if (  (_hx_switch_0==( (unsigned char)(17) )) ){
		if (!(( (bool)(val1) ))) {
			return val2;
		}
		else {
			return true;
		}
		goto _hx_goto_0;
	}
	if (  (_hx_switch_0==( (unsigned char)(18) )) ){
		if (( (bool)(val1) )) {
			return val2;
		}
		else {
			return false;
		}
		goto _hx_goto_0;
	}
	if (  (_hx_switch_0==( (unsigned char)(19) )) ){
		return ::Std_obj::isOfType(val1,val2);
		goto _hx_goto_0;
	}
	if (  (_hx_switch_0==( (unsigned char)(20) )) ){
		 ::Dynamic tmp = val1;
		if (::hx::IsNotNull( tmp )) {
			return tmp;
		}
		else {
			return val2;
		}
		goto _hx_goto_0;
	}
	if (  (_hx_switch_0==( (unsigned char)(21) )) ){
		return  ::IntIterator_obj::__alloc( HX_CTX ,( (int)(val1) ),( (int)(val2) ));
		goto _hx_goto_0;
	}
	if (  (_hx_switch_0==( (unsigned char)(22) )) ||  (_hx_switch_0==( (unsigned char)(23) )) ){
		return null();
		goto _hx_goto_0;
	}
	if (  (_hx_switch_0==( (unsigned char)(24) )) ){
		return (val1 + val2);
		goto _hx_goto_0;
	}
	if (  (_hx_switch_0==( (unsigned char)(25) )) ){
		return (( (Float)(val1) ) - ( (Float)(val2) ));
		goto _hx_goto_0;
	}
	if (  (_hx_switch_0==( (unsigned char)(26) )) ){
		return (( (Float)(val1) ) * ( (Float)(val2) ));
		goto _hx_goto_0;
	}
	if (  (_hx_switch_0==( (unsigned char)(27) )) ){
		return (( (Float)(val1) ) / ( (Float)(val2) ));
		goto _hx_goto_0;
	}
	if (  (_hx_switch_0==( (unsigned char)(28) )) ){
		return ::hx::Mod(val1,val2);
		goto _hx_goto_0;
	}
	if (  (_hx_switch_0==( (unsigned char)(29) )) ){
		return (( (int)(val1) ) << ( (int)(val2) ));
		goto _hx_goto_0;
	}
	if (  (_hx_switch_0==( (unsigned char)(30) )) ){
		return (( (int)(val1) ) >> ( (int)(val2) ));
		goto _hx_goto_0;
	}
	if (  (_hx_switch_0==( (unsigned char)(31) )) ){
		return ::hx::UShr(( (int)(val1) ),( (int)(val2) ));
		goto _hx_goto_0;
	}
	if (  (_hx_switch_0==( (unsigned char)(32) )) ){
		return (( (int)(val1) ) | ( (int)(val2) ));
		goto _hx_goto_0;
	}
	if (  (_hx_switch_0==( (unsigned char)(33) )) ){
		return (( (int)(val1) ) & ( (int)(val2) ));
		goto _hx_goto_0;
	}
	if (  (_hx_switch_0==( (unsigned char)(34) )) ){
		return (( (int)(val1) ) ^ ( (int)(val2) ));
		goto _hx_goto_0;
	}
	if (  (_hx_switch_0==( (unsigned char)(35) )) ){
		 ::Dynamic tmp1 = val1;
		if (::hx::IsNotNull( tmp1 )) {
			return tmp1;
		}
		else {
			return val2;
		}
		goto _hx_goto_0;
	}
	_hx_goto_0:;
	return null();
}


STATIC_HX_DEFINE_DYNAMIC_FUNC3(StaticInterp_obj,evaluateBinop,return )

 ::Dynamic StaticInterp_obj::evaluateConst( ::hscript::LConst _hx_const){
	switch((int)(_hx_const->_hx_getIndex())){
		case (int)0: {
			return _hx_const->_hx_getInt(0);
		}
		break;
		case (int)1: {
			return _hx_const->_hx_getFloat(0);
		}
		break;
		case (int)2: {
			return _hx_const->_hx_getString(0);
		}
		break;
		case (int)3: {
			return _hx_const->_hx_getBool(0);
		}
		break;
		case (int)4: {
			return null();
		}
		break;
	}
	return null();
}


STATIC_HX_DEFINE_DYNAMIC_FUNC1(StaticInterp_obj,evaluateConst,return )

 ::Dynamic StaticInterp_obj::getMapValue( ::Dynamic map, ::Dynamic key){
	return ::haxe::IMap_obj::get( ::hx::interface_check(map,0x09c2bd39),key);
}


STATIC_HX_DEFINE_DYNAMIC_FUNC2(StaticInterp_obj,getMapValue,return )

void StaticInterp_obj::setMapValue( ::Dynamic map, ::Dynamic key, ::Dynamic value){
	::haxe::IMap_obj::set( ::hx::interface_check(map,0x09c2bd39),key,value);
}


STATIC_HX_DEFINE_DYNAMIC_FUNC3(StaticInterp_obj,setMapValue,(void))

 ::haxe::ds::Either StaticInterp_obj::resolvePath(::String path){
	::hx::Class resolvedClass = ::Type_obj::resolveClass(path);
	if (::hx::IsNotNull( resolvedClass )) {
		return ::haxe::ds::Either_obj::Left(resolvedClass);
	}
	::hx::Class resolvedEnum = ::Type_obj::resolveEnum(path);
	if (::hx::IsNotNull( resolvedEnum )) {
		return ::haxe::ds::Either_obj::Right(resolvedEnum);
	}
	return null();
}


STATIC_HX_DEFINE_DYNAMIC_FUNC1(StaticInterp_obj,resolvePath,return )

 ::Dynamic StaticInterp_obj::resolveEnum(::hx::Class enums){
	 ::Dynamic enumStorage =  ::Dynamic(::hx::Anon_obj::Create(0));
	{
		int _g = 0;
		::Array< ::String > _g1 = ::Type_obj::getEnumConstructs(enums);
		while((_g < _g1->length)){
			::String name = _g1->__get(_g);
			_g = (_g + 1);
			try {
				HX_STACK_CATCHABLE( ::Dynamic, 0);
				::String name1 = name;
				::cpp::VirtualArray params = null();
				::Reflect_obj::setField(enumStorage,name1,::Type_obj::createEnum(enums,name,params));
			} catch( ::Dynamic _hx_e) {
				if (_hx_e.IsClass<  ::Dynamic >() ){
					HX_STACK_BEGIN_CATCH
					 ::Dynamic _g2 = _hx_e;
					{
						null();
					}
					try {
						HX_BEGIN_LOCAL_FUNC_S2(::hx::LocalFunc,_hx_Closure_0,::String,name,::hx::Class,enums) HXARGC(1)
						 ::Dynamic _hx_run(::cpp::VirtualArray args){
							return ::Type_obj::createEnum(enums,name,args);
						}
						HX_END_LOCAL_FUNC1(return)

						HX_STACK_CATCHABLE( ::Dynamic, 0);
						::String name2 = name;
						::Reflect_obj::setField(enumStorage,name2,::Reflect_obj::makeVarArgs( ::Dynamic(new _hx_Closure_0(name,enums))));
					} catch( ::Dynamic _hx_e) {
						if (_hx_e.IsClass<  ::Dynamic >() ){
							HX_STACK_BEGIN_CATCH
							 ::Dynamic _g3 = _hx_e;
							HX_STACK_DO_THROW(_g2);
						}
						else {
							HX_STACK_DO_THROW(_hx_e);
						}
					}
				}
				else {
					HX_STACK_DO_THROW(_hx_e);
				}
			}
		}
	}
	return enumStorage;
}


STATIC_HX_DEFINE_DYNAMIC_FUNC1(StaticInterp_obj,resolveEnum,return )

 ::Dynamic StaticInterp_obj::getObjectField( ::Dynamic object,::String field){
	if (::Std_obj::isOfType(object,::hx::ClassOf< ::hscript::IHScriptCustomBehaviour >())) {
		return ::hscript::IHScriptCustomBehaviour_obj::hget(object,field);
	}
	return ::Reflect_obj::getProperty(object,field);
}


STATIC_HX_DEFINE_DYNAMIC_FUNC2(StaticInterp_obj,getObjectField,return )

 ::Dynamic StaticInterp_obj::setObjectField( ::Dynamic object,::String field, ::Dynamic value){
	if (::Std_obj::isOfType(object,::hx::ClassOf< ::hscript::IHScriptCustomBehaviour >())) {
		return ::hscript::IHScriptCustomBehaviour_obj::hset(object,field,value);
	}
	::Reflect_obj::setProperty(object,field,value);
	return value;
}


STATIC_HX_DEFINE_DYNAMIC_FUNC3(StaticInterp_obj,setObjectField,return )

 ::Dynamic StaticInterp_obj::callObjectField( ::Dynamic object, ::Dynamic field,::cpp::VirtualArray args){
	return ::Reflect_obj::callMethod(object,field,args);
}


STATIC_HX_DEFINE_DYNAMIC_FUNC3(StaticInterp_obj,callObjectField,return )

 ::Dynamic StaticInterp_obj::makeIterator( ::Dynamic value){
	if (::hx::IsNotNull( value->__Field(HX_("iterator",ee,49,9a,93),::hx::paccDynamic) )) {
		try {
			HX_STACK_CATCHABLE( ::Dynamic, 0);
			value = value->__Field(HX_("iterator",ee,49,9a,93),::hx::paccDynamic)();
		} catch( ::Dynamic _hx_e) {
			if (_hx_e.IsClass<  ::Dynamic >() ){
				HX_STACK_BEGIN_CATCH
				 ::Dynamic _g = _hx_e;
				{
					null();
				}
			}
			else {
				HX_STACK_DO_THROW(_hx_e);
			}
		}
	}
	bool _hx_tmp;
	if (::hx::IsNotNull( value->__Field(HX_("hasNext",6d,a5,46,18),::hx::paccDynamic) )) {
		_hx_tmp = ::hx::IsNull( value->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic) );
	}
	else {
		_hx_tmp = true;
	}
	if (_hx_tmp) {
		return null();
	}
	return value;
}


STATIC_HX_DEFINE_DYNAMIC_FUNC1(StaticInterp_obj,makeIterator,return )

 ::Dynamic StaticInterp_obj::makeKeyValueIterator( ::Dynamic value){
	try {
		HX_STACK_CATCHABLE( ::Dynamic, 0);
		value = value->__Field(HX_("keyValueIterator",60,cd,ee,4a),::hx::paccDynamic)();
	} catch( ::Dynamic _hx_e) {
		if (_hx_e.IsClass<  ::Dynamic >() ){
			HX_STACK_BEGIN_CATCH
			 ::Dynamic _g = _hx_e;
			{
				null();
			}
		}
		else {
			HX_STACK_DO_THROW(_hx_e);
		}
	}
	bool _hx_tmp;
	if (::hx::IsNotNull( value->__Field(HX_("hasNext",6d,a5,46,18),::hx::paccDynamic) )) {
		_hx_tmp = ::hx::IsNull( value->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic) );
	}
	else {
		_hx_tmp = true;
	}
	if (_hx_tmp) {
		return null();
	}
	return value;
}


STATIC_HX_DEFINE_DYNAMIC_FUNC1(StaticInterp_obj,makeKeyValueIterator,return )

 ::Dynamic StaticInterp_obj::interpMap(::cpp::VirtualArray keys,::cpp::VirtualArray values){
            	HX_JUST_GC_STACKFRAME
	bool _hx_tmp;
	if ((keys->get_length() == 0)) {
		_hx_tmp = (values->get_length() == 0);
	}
	else {
		_hx_tmp = false;
	}
	if (_hx_tmp) {
		return  ::haxe::ds::StringMap_obj::__alloc( HX_CTX );
	}
	bool isAllString = true;
	bool isAllInt = true;
	bool isAllObject = true;
	bool isAllEnum = true;
	{
		int _g = 0;
		while((_g < keys->get_length())){
			 ::Dynamic key = keys->__get(_g);
			_g = (_g + 1);
			if (isAllString) {
				isAllString = ::Std_obj::isOfType(key,::hx::ClassOf< ::String >());
			}
			else {
				isAllString = false;
			}
			if (isAllInt) {
				isAllInt = ::Std_obj::isOfType(key,::hx::ClassOf< int >());
			}
			else {
				isAllInt = false;
			}
			if (isAllObject) {
				isAllObject = ::Reflect_obj::isObject(key);
			}
			else {
				isAllObject = false;
			}
			if (isAllEnum) {
				isAllEnum = ::Reflect_obj::isEnumValue(key);
			}
			else {
				isAllEnum = false;
			}
		}
	}
	::Dynamic map;
	if (isAllInt) {
		map =  ::haxe::ds::IntMap_obj::__alloc( HX_CTX );
	}
	else {
		if (isAllString) {
			map =  ::haxe::ds::StringMap_obj::__alloc( HX_CTX );
		}
		else {
			if (isAllEnum) {
				map =  ::haxe::ds::EnumValueMap_obj::__alloc( HX_CTX );
			}
			else {
				if (isAllObject) {
					map =  ::haxe::ds::ObjectMap_obj::__alloc( HX_CTX );
				}
				else {
					map =  ::haxe::ds::StringMap_obj::__alloc( HX_CTX );
				}
			}
		}
	}
	{
		int _g1 = 0;
		int _g2 = keys->get_length();
		while((_g1 < _g2)){
			_g1 = (_g1 + 1);
			int i = (_g1 - 1);
			::haxe::IMap_obj::set(map,keys->__get(i),values->__get(i));
		}
	}
	return map;
}


STATIC_HX_DEFINE_DYNAMIC_FUNC2(StaticInterp_obj,interpMap,return )


StaticInterp_obj::StaticInterp_obj()
{
}

bool StaticInterp_obj::__GetStatic(const ::String &inName, Dynamic &outValue, ::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 9:
		if (HX_FIELD_EQ(inName,"interpMap") ) { outValue = interpMap_dyn(); return true; }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"getMapValue") ) { outValue = getMapValue_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"setMapValue") ) { outValue = setMapValue_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"resolvePath") ) { outValue = resolvePath_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"resolveEnum") ) { outValue = resolveEnum_dyn(); return true; }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"makeIterator") ) { outValue = makeIterator_dyn(); return true; }
		break;
	case 13:
		if (HX_FIELD_EQ(inName,"evaluateBinop") ) { outValue = evaluateBinop_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"evaluateConst") ) { outValue = evaluateConst_dyn(); return true; }
		break;
	case 14:
		if (HX_FIELD_EQ(inName,"getObjectField") ) { outValue = getObjectField_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"setObjectField") ) { outValue = setObjectField_dyn(); return true; }
		break;
	case 15:
		if (HX_FIELD_EQ(inName,"staticVariables") ) { outValue = ( staticVariables ); return true; }
		if (HX_FIELD_EQ(inName,"callObjectField") ) { outValue = callObjectField_dyn(); return true; }
		break;
	case 20:
		if (HX_FIELD_EQ(inName,"makeKeyValueIterator") ) { outValue = makeKeyValueIterator_dyn(); return true; }
	}
	return false;
}

bool StaticInterp_obj::__SetStatic(const ::String &inName,Dynamic &ioValue,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 15:
		if (HX_FIELD_EQ(inName,"staticVariables") ) { staticVariables=ioValue.Cast<  ::haxe::ds::StringMap >(); return true; }
	}
	return false;
}

#ifdef HXCPP_SCRIPTABLE
static ::hx::StorageInfo *StaticInterp_obj_sMemberStorageInfo = 0;
static ::hx::StaticInfo StaticInterp_obj_sStaticStorageInfo[] = {
	{::hx::fsObject /*  ::haxe::ds::StringMap */ ,(void *) &StaticInterp_obj::staticVariables,HX_("staticVariables",29,e0,7b,b8)},
	{ ::hx::fsUnknown, 0, null()}
};
#endif

static void StaticInterp_obj_sMarkStatics(HX_MARK_PARAMS) {
	HX_MARK_MEMBER_NAME(StaticInterp_obj::staticVariables,"staticVariables");
};

#ifdef HXCPP_VISIT_ALLOCS
static void StaticInterp_obj_sVisitStatics(HX_VISIT_PARAMS) {
	HX_VISIT_MEMBER_NAME(StaticInterp_obj::staticVariables,"staticVariables");
};

#endif

::hx::Class StaticInterp_obj::__mClass;

static ::String StaticInterp_obj_sStaticFields[] = {
	HX_("staticVariables",29,e0,7b,b8),
	HX_("evaluateBinop",8f,46,44,5b),
	HX_("evaluateConst",4a,26,a2,f2),
	HX_("getMapValue",eb,b1,ee,ce),
	HX_("setMapValue",f7,b8,5b,d9),
	HX_("resolvePath",b1,0a,8d,e5),
	HX_("resolveEnum",0d,90,51,de),
	HX_("getObjectField",85,04,61,f7),
	HX_("setObjectField",f9,ec,80,17),
	HX_("callObjectField",7d,d9,e7,de),
	HX_("makeIterator",fc,dd,72,d8),
	HX_("makeKeyValueIterator",6e,1f,af,41),
	HX_("interpMap",28,25,67,40),
	::String(null())
};

void StaticInterp_obj::__register()
{
	StaticInterp_obj _hx_dummy;
	StaticInterp_obj::_hx_vtable = *(void **)&_hx_dummy;
	::hx::Static(__mClass) = new ::hx::Class_obj();
	__mClass->mName = HX_("hscript.StaticInterp",1d,c2,ff,6f);
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &StaticInterp_obj::__GetStatic;
	__mClass->mSetStaticField = &StaticInterp_obj::__SetStatic;
	__mClass->mMarkFunc = StaticInterp_obj_sMarkStatics;
	__mClass->mStatics = ::hx::Class_obj::dupFunctions(StaticInterp_obj_sStaticFields);
	__mClass->mMembers = ::hx::Class_obj::dupFunctions(0 /* sMemberFields */);
	__mClass->mCanCast = ::hx::TCanCast< StaticInterp_obj >;
#ifdef HXCPP_VISIT_ALLOCS
	__mClass->mVisitFunc = StaticInterp_obj_sVisitStatics;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = StaticInterp_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = StaticInterp_obj_sStaticStorageInfo;
#endif
	::hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

void StaticInterp_obj::__boot()
{
{
	HX_JUST_GC_STACKFRAME
	staticVariables =  ::haxe::ds::StringMap_obj::__alloc( HX_CTX );
}
}

} // end namespace hscript
