// Generated by Haxe 4.3.7
#include <hxcpp.h>

#ifndef INCLUDED_Std
#include <Std.h>
#endif
#ifndef INCLUDED_haxe_IMap
#include <haxe/IMap.h>
#endif
#ifndef INCLUDED_haxe_ds_StringMap
#include <haxe/ds/StringMap.h>
#endif
#ifndef INCLUDED_hscript__Lexer_LKeyword_Impl_
#include <hscript/_Lexer/LKeyword_Impl_.h>
#endif

static const ::String _hx_array_data_2647fe43_0[] = {
	HX_("as",f2,54,00,00),HX_("break",bf,24,ec,b8),HX_("case",b0,1e,ba,41),HX_("cast",bf,1e,ba,41),HX_("catch",3b,7c,21,41),HX_("continue",67,e0,c8,31),HX_("default",c1,d8,c3,9b),HX_("do",8b,57,00,00),HX_("else",b9,e4,14,43),HX_("false",a3,35,4f,fb),HX_("final",76,5f,9a,00),HX_("for",09,c7,4d,00),HX_("function",18,ab,52,14),HX_("if",dd,5b,00,00),HX_("import",65,a1,82,08),HX_("in",e5,5b,00,00),HX_("inline",59,ca,3f,99),HX_("new",60,d0,53,00),HX_("null",87,9e,0e,49),HX_("override",4c,22,28,49),HX_("private",03,2d,6f,89),HX_("public",a9,80,f3,66),HX_("return",b0,a4,2d,09),HX_("static",ae,dc,fb,05),HX_("switch",f4,49,79,c5),HX_("this",5e,06,fc,4c),HX_("throw",26,5d,90,0f),HX_("true",4e,a7,03,4d),HX_("try",3b,69,58,00),HX_("var",e7,de,59,00),HX_("while",b1,43,bd,c9),
};
namespace hscript{
namespace _Lexer{

void LKeyword_Impl__obj::__construct() { }

Dynamic LKeyword_Impl__obj::__CreateEmpty() { return new LKeyword_Impl__obj; }

void *LKeyword_Impl__obj::_hx_vtable = 0;

Dynamic LKeyword_Impl__obj::__Create(::hx::DynamicArray inArgs)
{
	::hx::ObjectPtr< LKeyword_Impl__obj > _hx_result = new LKeyword_Impl__obj();
	_hx_result->__construct();
	return _hx_result;
}

bool LKeyword_Impl__obj::_hx_isInstanceOf(int inClassId) {
	return inClassId==(int)0x00000001 || inClassId==(int)0x1bc229f5;
}

::String LKeyword_Impl__obj::AS;

::String LKeyword_Impl__obj::BREAK;

::String LKeyword_Impl__obj::CASE;

::String LKeyword_Impl__obj::CAST;

::String LKeyword_Impl__obj::CATCH;

::String LKeyword_Impl__obj::CONTINUE;

::String LKeyword_Impl__obj::DEFAULT;

::String LKeyword_Impl__obj::DO;

::String LKeyword_Impl__obj::ELSE;

::String LKeyword_Impl__obj::FALSE;

::String LKeyword_Impl__obj::FINAL;

::String LKeyword_Impl__obj::FOR;

::String LKeyword_Impl__obj::FUNCTION;

::String LKeyword_Impl__obj::IF;

::String LKeyword_Impl__obj::IMPORT;

::String LKeyword_Impl__obj::IN;

::String LKeyword_Impl__obj::INLINE;

::String LKeyword_Impl__obj::NEW;

::String LKeyword_Impl__obj::_hx_NULL;

::String LKeyword_Impl__obj::OVERRIDE;

::String LKeyword_Impl__obj::PRIVATE;

::String LKeyword_Impl__obj::PUBLIC;

::String LKeyword_Impl__obj::RETURN;

::String LKeyword_Impl__obj::STATIC;

::String LKeyword_Impl__obj::SWITCH;

::String LKeyword_Impl__obj::THIS;

::String LKeyword_Impl__obj::THROW;

::String LKeyword_Impl__obj::TRUE;

::String LKeyword_Impl__obj::TRY;

::String LKeyword_Impl__obj::VAR;

::String LKeyword_Impl__obj::WHILE;

::Array< ::String > LKeyword_Impl__obj::ALL_KEYWORDS;

 ::haxe::ds::StringMap LKeyword_Impl__obj::ALL_KEYWORDS_LOOKUP;


LKeyword_Impl__obj::LKeyword_Impl__obj()
{
}

#ifdef HXCPP_SCRIPTABLE
static ::hx::StorageInfo *LKeyword_Impl__obj_sMemberStorageInfo = 0;
static ::hx::StaticInfo LKeyword_Impl__obj_sStaticStorageInfo[] = {
	{::hx::fsString,(void *) &LKeyword_Impl__obj::AS,HX_("AS",f2,38,00,00)},
	{::hx::fsString,(void *) &LKeyword_Impl__obj::BREAK,HX_("BREAK",9f,5c,da,36)},
	{::hx::fsString,(void *) &LKeyword_Impl__obj::CASE,HX_("CASE",b0,e6,7a,2c)},
	{::hx::fsString,(void *) &LKeyword_Impl__obj::CAST,HX_("CAST",bf,e6,7a,2c)},
	{::hx::fsString,(void *) &LKeyword_Impl__obj::CATCH,HX_("CATCH",1b,b4,0f,bf)},
	{::hx::fsString,(void *) &LKeyword_Impl__obj::CONTINUE,HX_("CONTINUE",67,70,4e,8b)},
	{::hx::fsString,(void *) &LKeyword_Impl__obj::DEFAULT,HX_("DEFAULT",a1,ac,97,1b)},
	{::hx::fsString,(void *) &LKeyword_Impl__obj::DO,HX_("DO",8b,3b,00,00)},
	{::hx::fsString,(void *) &LKeyword_Impl__obj::ELSE,HX_("ELSE",b9,ac,d5,2d)},
	{::hx::fsString,(void *) &LKeyword_Impl__obj::FALSE,HX_("FALSE",83,6d,3d,79)},
	{::hx::fsString,(void *) &LKeyword_Impl__obj::FINAL,HX_("FINAL",56,97,88,7e)},
	{::hx::fsString,(void *) &LKeyword_Impl__obj::FOR,HX_("FOR",e9,62,35,00)},
	{::hx::fsString,(void *) &LKeyword_Impl__obj::FUNCTION,HX_("FUNCTION",18,3b,d8,6d)},
	{::hx::fsString,(void *) &LKeyword_Impl__obj::IF,HX_("IF",dd,3f,00,00)},
	{::hx::fsString,(void *) &LKeyword_Impl__obj::IMPORT,HX_("IMPORT",65,4d,05,bb)},
	{::hx::fsString,(void *) &LKeyword_Impl__obj::IN,HX_("IN",e5,3f,00,00)},
	{::hx::fsString,(void *) &LKeyword_Impl__obj::INLINE,HX_("INLINE",59,76,c2,4b)},
	{::hx::fsString,(void *) &LKeyword_Impl__obj::NEW,HX_("NEW",40,6c,3b,00)},
	{::hx::fsString,(void *) &LKeyword_Impl__obj::_hx_NULL,HX_("NULL",87,66,cf,33)},
	{::hx::fsString,(void *) &LKeyword_Impl__obj::OVERRIDE,HX_("OVERRIDE",4c,b2,ad,a2)},
	{::hx::fsString,(void *) &LKeyword_Impl__obj::PRIVATE,HX_("PRIVATE",e3,00,43,09)},
	{::hx::fsString,(void *) &LKeyword_Impl__obj::PUBLIC,HX_("PUBLIC",a9,2c,76,19)},
	{::hx::fsString,(void *) &LKeyword_Impl__obj::RETURN,HX_("RETURN",b0,50,b0,bb)},
	{::hx::fsString,(void *) &LKeyword_Impl__obj::STATIC,HX_("STATIC",ae,88,7e,b8)},
	{::hx::fsString,(void *) &LKeyword_Impl__obj::SWITCH,HX_("SWITCH",f4,f5,fb,77)},
	{::hx::fsString,(void *) &LKeyword_Impl__obj::THIS,HX_("THIS",5e,ce,bc,37)},
	{::hx::fsString,(void *) &LKeyword_Impl__obj::THROW,HX_("THROW",06,95,7e,8d)},
	{::hx::fsString,(void *) &LKeyword_Impl__obj::TRUE,HX_("TRUE",4e,6f,c4,37)},
	{::hx::fsString,(void *) &LKeyword_Impl__obj::TRY,HX_("TRY",1b,05,40,00)},
	{::hx::fsString,(void *) &LKeyword_Impl__obj::VAR,HX_("VAR",c7,7a,41,00)},
	{::hx::fsString,(void *) &LKeyword_Impl__obj::WHILE,HX_("WHILE",91,7b,ab,47)},
	{::hx::fsObject /* ::Array< ::String > */ ,(void *) &LKeyword_Impl__obj::ALL_KEYWORDS,HX_("ALL_KEYWORDS",a8,8f,7a,2a)},
	{::hx::fsObject /*  ::haxe::ds::StringMap */ ,(void *) &LKeyword_Impl__obj::ALL_KEYWORDS_LOOKUP,HX_("ALL_KEYWORDS_LOOKUP",71,95,4f,b2)},
	{ ::hx::fsUnknown, 0, null()}
};
#endif

static void LKeyword_Impl__obj_sMarkStatics(HX_MARK_PARAMS) {
	HX_MARK_MEMBER_NAME(LKeyword_Impl__obj::AS,"AS");
	HX_MARK_MEMBER_NAME(LKeyword_Impl__obj::BREAK,"BREAK");
	HX_MARK_MEMBER_NAME(LKeyword_Impl__obj::CASE,"CASE");
	HX_MARK_MEMBER_NAME(LKeyword_Impl__obj::CAST,"CAST");
	HX_MARK_MEMBER_NAME(LKeyword_Impl__obj::CATCH,"CATCH");
	HX_MARK_MEMBER_NAME(LKeyword_Impl__obj::CONTINUE,"CONTINUE");
	HX_MARK_MEMBER_NAME(LKeyword_Impl__obj::DEFAULT,"DEFAULT");
	HX_MARK_MEMBER_NAME(LKeyword_Impl__obj::DO,"DO");
	HX_MARK_MEMBER_NAME(LKeyword_Impl__obj::ELSE,"ELSE");
	HX_MARK_MEMBER_NAME(LKeyword_Impl__obj::FALSE,"FALSE");
	HX_MARK_MEMBER_NAME(LKeyword_Impl__obj::FINAL,"FINAL");
	HX_MARK_MEMBER_NAME(LKeyword_Impl__obj::FOR,"FOR");
	HX_MARK_MEMBER_NAME(LKeyword_Impl__obj::FUNCTION,"FUNCTION");
	HX_MARK_MEMBER_NAME(LKeyword_Impl__obj::IF,"IF");
	HX_MARK_MEMBER_NAME(LKeyword_Impl__obj::IMPORT,"IMPORT");
	HX_MARK_MEMBER_NAME(LKeyword_Impl__obj::IN,"IN");
	HX_MARK_MEMBER_NAME(LKeyword_Impl__obj::INLINE,"INLINE");
	HX_MARK_MEMBER_NAME(LKeyword_Impl__obj::NEW,"NEW");
	HX_MARK_MEMBER_NAME(LKeyword_Impl__obj::_hx_NULL,"NULL");
	HX_MARK_MEMBER_NAME(LKeyword_Impl__obj::OVERRIDE,"OVERRIDE");
	HX_MARK_MEMBER_NAME(LKeyword_Impl__obj::PRIVATE,"PRIVATE");
	HX_MARK_MEMBER_NAME(LKeyword_Impl__obj::PUBLIC,"PUBLIC");
	HX_MARK_MEMBER_NAME(LKeyword_Impl__obj::RETURN,"RETURN");
	HX_MARK_MEMBER_NAME(LKeyword_Impl__obj::STATIC,"STATIC");
	HX_MARK_MEMBER_NAME(LKeyword_Impl__obj::SWITCH,"SWITCH");
	HX_MARK_MEMBER_NAME(LKeyword_Impl__obj::THIS,"THIS");
	HX_MARK_MEMBER_NAME(LKeyword_Impl__obj::THROW,"THROW");
	HX_MARK_MEMBER_NAME(LKeyword_Impl__obj::TRUE,"TRUE");
	HX_MARK_MEMBER_NAME(LKeyword_Impl__obj::TRY,"TRY");
	HX_MARK_MEMBER_NAME(LKeyword_Impl__obj::VAR,"VAR");
	HX_MARK_MEMBER_NAME(LKeyword_Impl__obj::WHILE,"WHILE");
	HX_MARK_MEMBER_NAME(LKeyword_Impl__obj::ALL_KEYWORDS,"ALL_KEYWORDS");
	HX_MARK_MEMBER_NAME(LKeyword_Impl__obj::ALL_KEYWORDS_LOOKUP,"ALL_KEYWORDS_LOOKUP");
};

#ifdef HXCPP_VISIT_ALLOCS
static void LKeyword_Impl__obj_sVisitStatics(HX_VISIT_PARAMS) {
	HX_VISIT_MEMBER_NAME(LKeyword_Impl__obj::AS,"AS");
	HX_VISIT_MEMBER_NAME(LKeyword_Impl__obj::BREAK,"BREAK");
	HX_VISIT_MEMBER_NAME(LKeyword_Impl__obj::CASE,"CASE");
	HX_VISIT_MEMBER_NAME(LKeyword_Impl__obj::CAST,"CAST");
	HX_VISIT_MEMBER_NAME(LKeyword_Impl__obj::CATCH,"CATCH");
	HX_VISIT_MEMBER_NAME(LKeyword_Impl__obj::CONTINUE,"CONTINUE");
	HX_VISIT_MEMBER_NAME(LKeyword_Impl__obj::DEFAULT,"DEFAULT");
	HX_VISIT_MEMBER_NAME(LKeyword_Impl__obj::DO,"DO");
	HX_VISIT_MEMBER_NAME(LKeyword_Impl__obj::ELSE,"ELSE");
	HX_VISIT_MEMBER_NAME(LKeyword_Impl__obj::FALSE,"FALSE");
	HX_VISIT_MEMBER_NAME(LKeyword_Impl__obj::FINAL,"FINAL");
	HX_VISIT_MEMBER_NAME(LKeyword_Impl__obj::FOR,"FOR");
	HX_VISIT_MEMBER_NAME(LKeyword_Impl__obj::FUNCTION,"FUNCTION");
	HX_VISIT_MEMBER_NAME(LKeyword_Impl__obj::IF,"IF");
	HX_VISIT_MEMBER_NAME(LKeyword_Impl__obj::IMPORT,"IMPORT");
	HX_VISIT_MEMBER_NAME(LKeyword_Impl__obj::IN,"IN");
	HX_VISIT_MEMBER_NAME(LKeyword_Impl__obj::INLINE,"INLINE");
	HX_VISIT_MEMBER_NAME(LKeyword_Impl__obj::NEW,"NEW");
	HX_VISIT_MEMBER_NAME(LKeyword_Impl__obj::_hx_NULL,"NULL");
	HX_VISIT_MEMBER_NAME(LKeyword_Impl__obj::OVERRIDE,"OVERRIDE");
	HX_VISIT_MEMBER_NAME(LKeyword_Impl__obj::PRIVATE,"PRIVATE");
	HX_VISIT_MEMBER_NAME(LKeyword_Impl__obj::PUBLIC,"PUBLIC");
	HX_VISIT_MEMBER_NAME(LKeyword_Impl__obj::RETURN,"RETURN");
	HX_VISIT_MEMBER_NAME(LKeyword_Impl__obj::STATIC,"STATIC");
	HX_VISIT_MEMBER_NAME(LKeyword_Impl__obj::SWITCH,"SWITCH");
	HX_VISIT_MEMBER_NAME(LKeyword_Impl__obj::THIS,"THIS");
	HX_VISIT_MEMBER_NAME(LKeyword_Impl__obj::THROW,"THROW");
	HX_VISIT_MEMBER_NAME(LKeyword_Impl__obj::TRUE,"TRUE");
	HX_VISIT_MEMBER_NAME(LKeyword_Impl__obj::TRY,"TRY");
	HX_VISIT_MEMBER_NAME(LKeyword_Impl__obj::VAR,"VAR");
	HX_VISIT_MEMBER_NAME(LKeyword_Impl__obj::WHILE,"WHILE");
	HX_VISIT_MEMBER_NAME(LKeyword_Impl__obj::ALL_KEYWORDS,"ALL_KEYWORDS");
	HX_VISIT_MEMBER_NAME(LKeyword_Impl__obj::ALL_KEYWORDS_LOOKUP,"ALL_KEYWORDS_LOOKUP");
};

#endif

::hx::Class LKeyword_Impl__obj::__mClass;

static ::String LKeyword_Impl__obj_sStaticFields[] = {
	HX_("AS",f2,38,00,00),
	HX_("BREAK",9f,5c,da,36),
	HX_("CASE",b0,e6,7a,2c),
	HX_("CAST",bf,e6,7a,2c),
	HX_("CATCH",1b,b4,0f,bf),
	HX_("CONTINUE",67,70,4e,8b),
	HX_("DEFAULT",a1,ac,97,1b),
	HX_("DO",8b,3b,00,00),
	HX_("ELSE",b9,ac,d5,2d),
	HX_("FALSE",83,6d,3d,79),
	HX_("FINAL",56,97,88,7e),
	HX_("FOR",e9,62,35,00),
	HX_("FUNCTION",18,3b,d8,6d),
	HX_("IF",dd,3f,00,00),
	HX_("IMPORT",65,4d,05,bb),
	HX_("IN",e5,3f,00,00),
	HX_("INLINE",59,76,c2,4b),
	HX_("NEW",40,6c,3b,00),
	HX_("NULL",87,66,cf,33),
	HX_("OVERRIDE",4c,b2,ad,a2),
	HX_("PRIVATE",e3,00,43,09),
	HX_("PUBLIC",a9,2c,76,19),
	HX_("RETURN",b0,50,b0,bb),
	HX_("STATIC",ae,88,7e,b8),
	HX_("SWITCH",f4,f5,fb,77),
	HX_("THIS",5e,ce,bc,37),
	HX_("THROW",06,95,7e,8d),
	HX_("TRUE",4e,6f,c4,37),
	HX_("TRY",1b,05,40,00),
	HX_("VAR",c7,7a,41,00),
	HX_("WHILE",91,7b,ab,47),
	HX_("ALL_KEYWORDS",a8,8f,7a,2a),
	HX_("ALL_KEYWORDS_LOOKUP",71,95,4f,b2),
	::String(null())
};

void LKeyword_Impl__obj::__register()
{
	LKeyword_Impl__obj _hx_dummy;
	LKeyword_Impl__obj::_hx_vtable = *(void **)&_hx_dummy;
	::hx::Static(__mClass) = new ::hx::Class_obj();
	__mClass->mName = HX_("hscript._Lexer.LKeyword_Impl_",43,fe,47,26);
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &::hx::Class_obj::GetNoStaticField;
	__mClass->mSetStaticField = &::hx::Class_obj::SetNoStaticField;
	__mClass->mMarkFunc = LKeyword_Impl__obj_sMarkStatics;
	__mClass->mStatics = ::hx::Class_obj::dupFunctions(LKeyword_Impl__obj_sStaticFields);
	__mClass->mMembers = ::hx::Class_obj::dupFunctions(0 /* sMemberFields */);
	__mClass->mCanCast = ::hx::TCanCast< LKeyword_Impl__obj >;
#ifdef HXCPP_VISIT_ALLOCS
	__mClass->mVisitFunc = LKeyword_Impl__obj_sVisitStatics;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = LKeyword_Impl__obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = LKeyword_Impl__obj_sStaticStorageInfo;
#endif
	::hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

void LKeyword_Impl__obj::__boot()
{
{
	AS = HX_("as",f2,54,00,00);
}
{
	BREAK = HX_("break",bf,24,ec,b8);
}
{
	CASE = HX_("case",b0,1e,ba,41);
}
{
	CAST = HX_("cast",bf,1e,ba,41);
}
{
	CATCH = HX_("catch",3b,7c,21,41);
}
{
	CONTINUE = HX_("continue",67,e0,c8,31);
}
{
	DEFAULT = HX_("default",c1,d8,c3,9b);
}
{
	DO = HX_("do",8b,57,00,00);
}
{
	ELSE = HX_("else",b9,e4,14,43);
}
{
	FALSE = HX_("false",a3,35,4f,fb);
}
{
	FINAL = HX_("final",76,5f,9a,00);
}
{
	FOR = HX_("for",09,c7,4d,00);
}
{
	FUNCTION = HX_("function",18,ab,52,14);
}
{
	IF = HX_("if",dd,5b,00,00);
}
{
	IMPORT = HX_("import",65,a1,82,08);
}
{
	IN = HX_("in",e5,5b,00,00);
}
{
	INLINE = HX_("inline",59,ca,3f,99);
}
{
	NEW = HX_("new",60,d0,53,00);
}
{
	_hx_NULL = HX_("null",87,9e,0e,49);
}
{
	OVERRIDE = HX_("override",4c,22,28,49);
}
{
	PRIVATE = HX_("private",03,2d,6f,89);
}
{
	PUBLIC = HX_("public",a9,80,f3,66);
}
{
	RETURN = HX_("return",b0,a4,2d,09);
}
{
	STATIC = HX_("static",ae,dc,fb,05);
}
{
	SWITCH = HX_("switch",f4,49,79,c5);
}
{
	THIS = HX_("this",5e,06,fc,4c);
}
{
	THROW = HX_("throw",26,5d,90,0f);
}
{
	TRUE = HX_("true",4e,a7,03,4d);
}
{
	TRY = HX_("try",3b,69,58,00);
}
{
	VAR = HX_("var",e7,de,59,00);
}
{
	WHILE = HX_("while",b1,43,bd,c9);
}
{
	ALL_KEYWORDS = ::Array_obj< ::String >::fromData( _hx_array_data_2647fe43_0,31);
}
{
	HX_BEGIN_LOCAL_FUNC_S0(::hx::LocalFunc,_hx_Closure_0) HXARGC(0)
	 ::haxe::ds::StringMap _hx_run(){
		HX_JUST_GC_STACKFRAME
		 ::haxe::ds::StringMap LOOKUP_MAP =  ::haxe::ds::StringMap_obj::__alloc( HX_CTX );
		{
			int _g = 0;
			::Array< ::String > _g1 = ::hscript::_Lexer::LKeyword_Impl__obj::ALL_KEYWORDS;
			while((_g < _g1->length)){
				::String keyword = _g1->__get(_g);
				_g = (_g + 1);
				LOOKUP_MAP->set(::Std_obj::string(keyword),keyword);
			}
		}
		return LOOKUP_MAP;
	}
	HX_END_LOCAL_FUNC0(return)

	ALL_KEYWORDS_LOOKUP = ( ( ::haxe::ds::StringMap)( ::Dynamic(new _hx_Closure_0())()) );
}
}

} // end namespace hscript
} // end namespace _Lexer
