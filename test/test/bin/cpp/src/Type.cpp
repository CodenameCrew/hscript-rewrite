// Generated by Haxe 4.3.7
#include <hxcpp.h>

#ifndef INCLUDED_Reflect
#include <Reflect.h>
#endif
#ifndef INCLUDED_Std
#include <Std.h>
#endif
#ifndef INCLUDED_Type
#include <Type.h>
#endif
#ifndef INCLUDED_ValueType
#include <ValueType.h>
#endif
#ifndef INCLUDED_haxe_Exception
#include <haxe/Exception.h>
#endif
#ifndef INCLUDED_haxe_ValueException
#include <haxe/ValueException.h>
#endif


void Type_obj::__construct() { }

Dynamic Type_obj::__CreateEmpty() { return new Type_obj; }

void *Type_obj::_hx_vtable = 0;

Dynamic Type_obj::__Create(::hx::DynamicArray inArgs)
{
	::hx::ObjectPtr< Type_obj > _hx_result = new Type_obj();
	_hx_result->__construct();
	return _hx_result;
}

bool Type_obj::_hx_isInstanceOf(int inClassId) {
	return inClassId==(int)0x00000001 || inClassId==(int)0x0c3514fe;
}

::hx::Class Type_obj::getClass( ::Dynamic o){
	bool _hx_tmp;
	if (::hx::IsNotNull( o )) {
		_hx_tmp = !(::Reflect_obj::isObject(o));
	}
	else {
		_hx_tmp = true;
	}
	if (_hx_tmp) {
		return null();
	}
	 ::Dynamic c = o->__GetClass();
	::String _hx_switch_0 = ( (::String)(c->toString()) );
	if (  (_hx_switch_0==HX_("Class",18,e8,85,db)) ){
		return null();
		goto _hx_goto_0;
	}
	if (  (_hx_switch_0==HX_("__Anon",8c,1a,43,da)) ){
		return null();
		goto _hx_goto_0;
	}
	_hx_goto_0:;
	return c;
}


STATIC_HX_DEFINE_DYNAMIC_FUNC1(Type_obj,getClass,return )

::hx::Class Type_obj::getEnum( ::Dynamic o){
	if (::hx::IsNull( o )) {
		return null();
	}
	return o->__GetClass();
}


STATIC_HX_DEFINE_DYNAMIC_FUNC1(Type_obj,getEnum,return )

::hx::Class Type_obj::getSuperClass(::hx::Class c){
	return c->GetSuper();
}


STATIC_HX_DEFINE_DYNAMIC_FUNC1(Type_obj,getSuperClass,return )

::String Type_obj::getClassName(::hx::Class c){
	if (::hx::IsNull( c )) {
		return null();
	}
	return c->mName;
}


STATIC_HX_DEFINE_DYNAMIC_FUNC1(Type_obj,getClassName,return )

::String Type_obj::getEnumName(::hx::Class e){
	return ( (::String)(e->__ToString()) );
}


STATIC_HX_DEFINE_DYNAMIC_FUNC1(Type_obj,getEnumName,return )

::hx::Class Type_obj::resolveClass(::String name){
	::hx::Class result =  ::hx::Class_obj::Resolve(name);
	bool _hx_tmp;
	if (::hx::IsNotNull( result )) {
		_hx_tmp = ( (bool)(result->__IsEnum()) );
	}
	else {
		_hx_tmp = false;
	}
	if (_hx_tmp) {
		return null();
	}
	return result;
}


STATIC_HX_DEFINE_DYNAMIC_FUNC1(Type_obj,resolveClass,return )

::hx::Class Type_obj::resolveEnum(::String name){
	::hx::Class result =  ::hx::Class_obj::Resolve(name);
	bool _hx_tmp;
	if (::hx::IsNotNull( result )) {
		_hx_tmp = !(( (bool)(result->__IsEnum()) ));
	}
	else {
		_hx_tmp = false;
	}
	if (_hx_tmp) {
		return null();
	}
	return result;
}


STATIC_HX_DEFINE_DYNAMIC_FUNC1(Type_obj,resolveEnum,return )

 ::Dynamic Type_obj::createInstance(::hx::Class cl,::cpp::VirtualArray args){
	if (::hx::IsNotNull( cl )) {
		return cl->ConstructArgs(args);
	}
	return null();
}


STATIC_HX_DEFINE_DYNAMIC_FUNC2(Type_obj,createInstance,return )

 ::Dynamic Type_obj::createEmptyInstance(::hx::Class cl){
	return cl->ConstructEmpty();
}


STATIC_HX_DEFINE_DYNAMIC_FUNC1(Type_obj,createEmptyInstance,return )

 ::Dynamic Type_obj::createEnum(::hx::Class e,::String constr,::cpp::VirtualArray params){
	return e->ConstructEnum(constr,params);
}


STATIC_HX_DEFINE_DYNAMIC_FUNC3(Type_obj,createEnum,return )

 ::Dynamic Type_obj::createEnumIndex(::hx::Class e,int index,::cpp::VirtualArray params){
	::String c = ::Type_obj::getEnumConstructs(e)->__get(index);
	if (::hx::IsNull( c )) {
		HX_STACK_DO_THROW((index + HX_(" is not a valid enum constructor index",13,f3,cb,7c)));
	}
	return ::Type_obj::createEnum(e,c,params);
}


STATIC_HX_DEFINE_DYNAMIC_FUNC3(Type_obj,createEnumIndex,return )

::Array< ::String > Type_obj::getInstanceFields(::hx::Class c){
	return ( (::Array< ::String >)(c->GetInstanceFields()) );
}


STATIC_HX_DEFINE_DYNAMIC_FUNC1(Type_obj,getInstanceFields,return )

::Array< ::String > Type_obj::getClassFields(::hx::Class c){
	return ( (::Array< ::String >)(c->GetClassFields()) );
}


STATIC_HX_DEFINE_DYNAMIC_FUNC1(Type_obj,getClassFields,return )

::Array< ::String > Type_obj::getEnumConstructs(::hx::Class e){
	return ( (::Array< ::String >)(e->GetClassFields()) );
}


STATIC_HX_DEFINE_DYNAMIC_FUNC1(Type_obj,getEnumConstructs,return )

 ::ValueType Type_obj::_hx_typeof( ::Dynamic v){
	if (::hx::IsNull( v )) {
		return ::ValueType_obj::TNull_dyn();
	}
	int t = ( (int)(v->__GetType()) );
	switch((int)(t)){
		case (int)1: {
			return ::ValueType_obj::TFloat_dyn();
		}
		break;
		case (int)2: {
			return ::ValueType_obj::TBool_dyn();
		}
		break;
		case (int)4: {
			return ::ValueType_obj::TObject_dyn();
		}
		break;
		case (int)6: {
			return ::ValueType_obj::TFunction_dyn();
		}
		break;
		case (int)7: {
			return ::ValueType_obj::TEnum(v->__GetClass());
		}
		break;
		case (int)255: {
			return ::ValueType_obj::TInt_dyn();
		}
		break;
		default:{
			return ::ValueType_obj::TClass(v->__GetClass());
		}
	}
	return null();
}


STATIC_HX_DEFINE_DYNAMIC_FUNC1(Type_obj,_hx_typeof,return )

bool Type_obj::enumEq( ::Dynamic a, ::Dynamic b){
	return __hxcpp_enum_eq(a,b);
}


STATIC_HX_DEFINE_DYNAMIC_FUNC2(Type_obj,enumEq,return )

::String Type_obj::enumConstructor( ::Dynamic e){
	return ( ( hx::EnumBase)(e) )->_hx_getTag();
}


STATIC_HX_DEFINE_DYNAMIC_FUNC1(Type_obj,enumConstructor,return )

::cpp::VirtualArray Type_obj::enumParameters( ::Dynamic e){
	return ( ( hx::EnumBase)(e) )->_hx_getParameters();
}


STATIC_HX_DEFINE_DYNAMIC_FUNC1(Type_obj,enumParameters,return )

int Type_obj::enumIndex( ::Dynamic e){
	return _hx_getEnumValueIndex(e);
}


STATIC_HX_DEFINE_DYNAMIC_FUNC1(Type_obj,enumIndex,return )

::cpp::VirtualArray Type_obj::allEnums(::hx::Class e){
	::Array< ::String > names = ( (::Array< ::String >)(e->GetClassFields()) );
	::cpp::VirtualArray enums = ::cpp::VirtualArray_obj::__new();
	{
		int _g = 0;
		while((_g < names->length)){
			::String name = names->__get(_g);
			_g = (_g + 1);
			try {
				HX_STACK_CATCHABLE(::String, 0);
				HX_STACK_CATCHABLE( ::haxe::ValueException, 1);
				 ::Dynamic result = e->ConstructEnum(name,null());
				if (::hx::IsNotNull( result )) {
					enums->push(result);
				}
			} catch( ::Dynamic _hx_e) {
				if (_hx_e.IsClass< ::String >() && _hx_e->toString()!=null() ){
					HX_STACK_BEGIN_CATCH
					::String invalidArgCount = _hx_e;
				}
				else if (_hx_e.IsClass<  ::haxe::ValueException >() ){
					HX_STACK_BEGIN_CATCH
					 ::haxe::ValueException _g1 = _hx_e;
					{
						null();
					}
					if (!(::Std_obj::isOfType(_g1->value,::hx::ClassOf< ::String >()))) {
						HX_STACK_DO_THROW(_g1);
					}
				}
				else {
					HX_STACK_DO_THROW(_hx_e);
				}
			}
		}
	}
	return enums;
}


STATIC_HX_DEFINE_DYNAMIC_FUNC1(Type_obj,allEnums,return )


Type_obj::Type_obj()
{
}

bool Type_obj::__GetStatic(const ::String &inName, Dynamic &outValue, ::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 6:
		if (HX_FIELD_EQ(inName,"typeof") ) { outValue = _hx_typeof_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"enumEq") ) { outValue = enumEq_dyn(); return true; }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"getEnum") ) { outValue = getEnum_dyn(); return true; }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"getClass") ) { outValue = getClass_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"allEnums") ) { outValue = allEnums_dyn(); return true; }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"enumIndex") ) { outValue = enumIndex_dyn(); return true; }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"createEnum") ) { outValue = createEnum_dyn(); return true; }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"getEnumName") ) { outValue = getEnumName_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"resolveEnum") ) { outValue = resolveEnum_dyn(); return true; }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"getClassName") ) { outValue = getClassName_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"resolveClass") ) { outValue = resolveClass_dyn(); return true; }
		break;
	case 13:
		if (HX_FIELD_EQ(inName,"getSuperClass") ) { outValue = getSuperClass_dyn(); return true; }
		break;
	case 14:
		if (HX_FIELD_EQ(inName,"createInstance") ) { outValue = createInstance_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"getClassFields") ) { outValue = getClassFields_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"enumParameters") ) { outValue = enumParameters_dyn(); return true; }
		break;
	case 15:
		if (HX_FIELD_EQ(inName,"createEnumIndex") ) { outValue = createEnumIndex_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"enumConstructor") ) { outValue = enumConstructor_dyn(); return true; }
		break;
	case 17:
		if (HX_FIELD_EQ(inName,"getInstanceFields") ) { outValue = getInstanceFields_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"getEnumConstructs") ) { outValue = getEnumConstructs_dyn(); return true; }
		break;
	case 19:
		if (HX_FIELD_EQ(inName,"createEmptyInstance") ) { outValue = createEmptyInstance_dyn(); return true; }
	}
	return false;
}

#ifdef HXCPP_SCRIPTABLE
static ::hx::StorageInfo *Type_obj_sMemberStorageInfo = 0;
static ::hx::StaticInfo *Type_obj_sStaticStorageInfo = 0;
#endif

::hx::Class Type_obj::__mClass;

static ::String Type_obj_sStaticFields[] = {
	HX_("getClass",c2,87,2f,a8),
	HX_("getEnum",b7,1a,99,15),
	HX_("getSuperClass",f3,04,7a,04),
	HX_("getClassName",2d,2f,94,eb),
	HX_("getEnumName",a2,e0,5a,53),
	HX_("resolveClass",ac,bd,dd,80),
	HX_("resolveEnum",0d,90,51,de),
	HX_("createInstance",b1,9e,1b,ac),
	HX_("createEmptyInstance",a6,26,85,ce),
	HX_("createEnum",1d,2c,a4,55),
	HX_("createEnumIndex",b5,d5,57,55),
	HX_("getInstanceFields",24,2f,97,ed),
	HX_("getClassFields",db,c7,75,7f),
	HX_("getEnumConstructs",13,06,6d,83),
	HX_("typeof",51,f6,36,57),
	HX_("enumEq",cd,29,c8,05),
	HX_("enumConstructor",79,a7,32,c9),
	HX_("enumParameters",0b,59,78,fa),
	HX_("enumIndex",51,1c,63,b4),
	HX_("allEnums",71,f5,6a,69),
	::String(null())
};

void Type_obj::__register()
{
	Type_obj _hx_dummy;
	Type_obj::_hx_vtable = *(void **)&_hx_dummy;
	::hx::Static(__mClass) = new ::hx::Class_obj();
	__mClass->mName = HX_("Type",da,1e,e2,37);
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &Type_obj::__GetStatic;
	__mClass->mSetStaticField = &::hx::Class_obj::SetNoStaticField;
	__mClass->mStatics = ::hx::Class_obj::dupFunctions(Type_obj_sStaticFields);
	__mClass->mMembers = ::hx::Class_obj::dupFunctions(0 /* sMemberFields */);
	__mClass->mCanCast = ::hx::TCanCast< Type_obj >;
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = Type_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = Type_obj_sStaticStorageInfo;
#endif
	::hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

