// Generated by Haxe 4.3.7
#include <hxcpp.h>

#ifndef INCLUDED_Xml
#include <Xml.h>
#endif
#ifndef INCLUDED__Xml_XmlType_Impl_
#include <_Xml/XmlType_Impl_.h>
#endif
#ifndef INCLUDED_haxe_IMap
#include <haxe/IMap.h>
#endif
#ifndef INCLUDED_haxe_ds_StringMap
#include <haxe/ds/StringMap.h>
#endif
#ifndef INCLUDED_haxe_iterators_ArrayIterator
#include <haxe/iterators/ArrayIterator.h>
#endif
#ifndef INCLUDED_haxe_xml_Parser
#include <haxe/xml/Parser.h>
#endif
#ifndef INCLUDED_haxe_xml_Printer
#include <haxe/xml/Printer.h>
#endif


void Xml_obj::__construct(int nodeType){
            	HX_JUST_GC_STACKFRAME
	this->nodeType = nodeType;
	this->children = ::Array_obj< ::Dynamic>::__new(0);
	this->attributeMap =  ::haxe::ds::StringMap_obj::__alloc( HX_CTX );
}

Dynamic Xml_obj::__CreateEmpty() { return new Xml_obj; }

void *Xml_obj::_hx_vtable = 0;

Dynamic Xml_obj::__Create(::hx::DynamicArray inArgs)
{
	::hx::ObjectPtr< Xml_obj > _hx_result = new Xml_obj();
	_hx_result->__construct(inArgs[0]);
	return _hx_result;
}

bool Xml_obj::_hx_isInstanceOf(int inClassId) {
	return inClassId==(int)0x00000001 || inClassId==(int)0x7ee76a4b;
}

::String Xml_obj::get_nodeName(){
	if ((this->nodeType != ::Xml_obj::Element)) {
		HX_STACK_DO_THROW((HX_("Bad node type, expected Element but found ",d8,90,8b,bb) + ::_Xml::XmlType_Impl__obj::toString(this->nodeType)));
	}
	return this->nodeName;
}


HX_DEFINE_DYNAMIC_FUNC0(Xml_obj,get_nodeName,return )

::String Xml_obj::set_nodeName(::String v){
	if ((this->nodeType != ::Xml_obj::Element)) {
		HX_STACK_DO_THROW((HX_("Bad node type, expected Element but found ",d8,90,8b,bb) + ::_Xml::XmlType_Impl__obj::toString(this->nodeType)));
	}
	return (this->nodeName = v);
}


HX_DEFINE_DYNAMIC_FUNC1(Xml_obj,set_nodeName,return )

::String Xml_obj::get_nodeValue(){
	bool _hx_tmp;
	if ((this->nodeType != ::Xml_obj::Document)) {
		_hx_tmp = (this->nodeType == ::Xml_obj::Element);
	}
	else {
		_hx_tmp = true;
	}
	if (_hx_tmp) {
		HX_STACK_DO_THROW((HX_("Bad node type, unexpected ",be,79,d5,11) + ::_Xml::XmlType_Impl__obj::toString(this->nodeType)));
	}
	return this->nodeValue;
}


HX_DEFINE_DYNAMIC_FUNC0(Xml_obj,get_nodeValue,return )

::String Xml_obj::set_nodeValue(::String v){
	bool _hx_tmp;
	if ((this->nodeType != ::Xml_obj::Document)) {
		_hx_tmp = (this->nodeType == ::Xml_obj::Element);
	}
	else {
		_hx_tmp = true;
	}
	if (_hx_tmp) {
		HX_STACK_DO_THROW((HX_("Bad node type, unexpected ",be,79,d5,11) + ::_Xml::XmlType_Impl__obj::toString(this->nodeType)));
	}
	return (this->nodeValue = v);
}


HX_DEFINE_DYNAMIC_FUNC1(Xml_obj,set_nodeValue,return )

::String Xml_obj::get(::String att){
	if ((this->nodeType != ::Xml_obj::Element)) {
		HX_STACK_DO_THROW((HX_("Bad node type, expected Element but found ",d8,90,8b,bb) + ::_Xml::XmlType_Impl__obj::toString(this->nodeType)));
	}
	return this->attributeMap->get_string(att);
}


HX_DEFINE_DYNAMIC_FUNC1(Xml_obj,get,return )

void Xml_obj::set(::String att,::String value){
	if ((this->nodeType != ::Xml_obj::Element)) {
		HX_STACK_DO_THROW((HX_("Bad node type, expected Element but found ",d8,90,8b,bb) + ::_Xml::XmlType_Impl__obj::toString(this->nodeType)));
	}
	this->attributeMap->set(att,value);
}


HX_DEFINE_DYNAMIC_FUNC2(Xml_obj,set,(void))

void Xml_obj::remove(::String att){
	if ((this->nodeType != ::Xml_obj::Element)) {
		HX_STACK_DO_THROW((HX_("Bad node type, expected Element but found ",d8,90,8b,bb) + ::_Xml::XmlType_Impl__obj::toString(this->nodeType)));
	}
	this->attributeMap->remove(att);
}


HX_DEFINE_DYNAMIC_FUNC1(Xml_obj,remove,(void))

bool Xml_obj::exists(::String att){
	if ((this->nodeType != ::Xml_obj::Element)) {
		HX_STACK_DO_THROW((HX_("Bad node type, expected Element but found ",d8,90,8b,bb) + ::_Xml::XmlType_Impl__obj::toString(this->nodeType)));
	}
	return this->attributeMap->exists(att);
}


HX_DEFINE_DYNAMIC_FUNC1(Xml_obj,exists,return )

 ::Dynamic Xml_obj::attributes(){
	if ((this->nodeType != ::Xml_obj::Element)) {
		HX_STACK_DO_THROW((HX_("Bad node type, expected Element but found ",d8,90,8b,bb) + ::_Xml::XmlType_Impl__obj::toString(this->nodeType)));
	}
	return this->attributeMap->keys();
}


HX_DEFINE_DYNAMIC_FUNC0(Xml_obj,attributes,return )

 ::Dynamic Xml_obj::iterator(){
            	HX_JUST_GC_STACKFRAME
	bool _hx_tmp;
	if ((this->nodeType != ::Xml_obj::Document)) {
		_hx_tmp = (this->nodeType != ::Xml_obj::Element);
	}
	else {
		_hx_tmp = false;
	}
	if (_hx_tmp) {
		HX_STACK_DO_THROW((HX_("Bad node type, expected Element or Document but found ",a0,d6,ba,79) + ::_Xml::XmlType_Impl__obj::toString(this->nodeType)));
	}
	return  ::haxe::iterators::ArrayIterator_obj::__alloc( HX_CTX ,this->children);
}


HX_DEFINE_DYNAMIC_FUNC0(Xml_obj,iterator,return )

 ::Dynamic Xml_obj::elements(){
            	HX_JUST_GC_STACKFRAME
	bool _hx_tmp;
	if ((this->nodeType != ::Xml_obj::Document)) {
		_hx_tmp = (this->nodeType != ::Xml_obj::Element);
	}
	else {
		_hx_tmp = false;
	}
	if (_hx_tmp) {
		HX_STACK_DO_THROW((HX_("Bad node type, expected Element or Document but found ",a0,d6,ba,79) + ::_Xml::XmlType_Impl__obj::toString(this->nodeType)));
	}
	::Array< ::Dynamic> _g = ::Array_obj< ::Dynamic>::__new(0);
	{
		int _g1 = 0;
		::Array< ::Dynamic> _g2 = this->children;
		while((_g1 < _g2->length)){
			 ::Xml child = _g2->__get(_g1).StaticCast<  ::Xml >();
			_g1 = (_g1 + 1);
			if ((child->nodeType == ::Xml_obj::Element)) {
				_g->push(child);
			}
		}
	}
	return  ::haxe::iterators::ArrayIterator_obj::__alloc( HX_CTX ,_g);
}


HX_DEFINE_DYNAMIC_FUNC0(Xml_obj,elements,return )

 ::Dynamic Xml_obj::elementsNamed(::String name){
            	HX_JUST_GC_STACKFRAME
	bool _hx_tmp;
	if ((this->nodeType != ::Xml_obj::Document)) {
		_hx_tmp = (this->nodeType != ::Xml_obj::Element);
	}
	else {
		_hx_tmp = false;
	}
	if (_hx_tmp) {
		HX_STACK_DO_THROW((HX_("Bad node type, expected Element or Document but found ",a0,d6,ba,79) + ::_Xml::XmlType_Impl__obj::toString(this->nodeType)));
	}
	::Array< ::Dynamic> _g = ::Array_obj< ::Dynamic>::__new(0);
	{
		int _g1 = 0;
		::Array< ::Dynamic> _g2 = this->children;
		while((_g1 < _g2->length)){
			 ::Xml child = _g2->__get(_g1).StaticCast<  ::Xml >();
			_g1 = (_g1 + 1);
			bool _hx_tmp1;
			if ((child->nodeType == ::Xml_obj::Element)) {
				if ((child->nodeType != ::Xml_obj::Element)) {
					HX_STACK_DO_THROW((HX_("Bad node type, expected Element but found ",d8,90,8b,bb) + ::_Xml::XmlType_Impl__obj::toString(child->nodeType)));
				}
				_hx_tmp1 = (child->nodeName == name);
			}
			else {
				_hx_tmp1 = false;
			}
			if (_hx_tmp1) {
				_g->push(child);
			}
		}
	}
	return  ::haxe::iterators::ArrayIterator_obj::__alloc( HX_CTX ,_g);
}


HX_DEFINE_DYNAMIC_FUNC1(Xml_obj,elementsNamed,return )

 ::Xml Xml_obj::firstChild(){
	bool _hx_tmp;
	if ((this->nodeType != ::Xml_obj::Document)) {
		_hx_tmp = (this->nodeType != ::Xml_obj::Element);
	}
	else {
		_hx_tmp = false;
	}
	if (_hx_tmp) {
		HX_STACK_DO_THROW((HX_("Bad node type, expected Element or Document but found ",a0,d6,ba,79) + ::_Xml::XmlType_Impl__obj::toString(this->nodeType)));
	}
	return this->children->__get(0).StaticCast<  ::Xml >();
}


HX_DEFINE_DYNAMIC_FUNC0(Xml_obj,firstChild,return )

 ::Xml Xml_obj::firstElement(){
	bool _hx_tmp;
	if ((this->nodeType != ::Xml_obj::Document)) {
		_hx_tmp = (this->nodeType != ::Xml_obj::Element);
	}
	else {
		_hx_tmp = false;
	}
	if (_hx_tmp) {
		HX_STACK_DO_THROW((HX_("Bad node type, expected Element or Document but found ",a0,d6,ba,79) + ::_Xml::XmlType_Impl__obj::toString(this->nodeType)));
	}
	{
		int _g = 0;
		::Array< ::Dynamic> _g1 = this->children;
		while((_g < _g1->length)){
			 ::Xml child = _g1->__get(_g).StaticCast<  ::Xml >();
			_g = (_g + 1);
			if ((child->nodeType == ::Xml_obj::Element)) {
				return child;
			}
		}
	}
	return null();
}


HX_DEFINE_DYNAMIC_FUNC0(Xml_obj,firstElement,return )

void Xml_obj::addChild( ::Xml x){
	bool _hx_tmp;
	if ((this->nodeType != ::Xml_obj::Document)) {
		_hx_tmp = (this->nodeType != ::Xml_obj::Element);
	}
	else {
		_hx_tmp = false;
	}
	if (_hx_tmp) {
		HX_STACK_DO_THROW((HX_("Bad node type, expected Element or Document but found ",a0,d6,ba,79) + ::_Xml::XmlType_Impl__obj::toString(this->nodeType)));
	}
	if (::hx::IsNotNull( x->parent )) {
		x->parent->removeChild(x);
	}
	this->children->push(x);
	x->parent = ::hx::ObjectPtr<OBJ_>(this);
}


HX_DEFINE_DYNAMIC_FUNC1(Xml_obj,addChild,(void))

bool Xml_obj::removeChild( ::Xml x){
	bool _hx_tmp;
	if ((this->nodeType != ::Xml_obj::Document)) {
		_hx_tmp = (this->nodeType != ::Xml_obj::Element);
	}
	else {
		_hx_tmp = false;
	}
	if (_hx_tmp) {
		HX_STACK_DO_THROW((HX_("Bad node type, expected Element or Document but found ",a0,d6,ba,79) + ::_Xml::XmlType_Impl__obj::toString(this->nodeType)));
	}
	if (this->children->remove(x)) {
		x->parent = null();
		return true;
	}
	return false;
}


HX_DEFINE_DYNAMIC_FUNC1(Xml_obj,removeChild,return )

void Xml_obj::insertChild( ::Xml x,int pos){
	bool _hx_tmp;
	if ((this->nodeType != ::Xml_obj::Document)) {
		_hx_tmp = (this->nodeType != ::Xml_obj::Element);
	}
	else {
		_hx_tmp = false;
	}
	if (_hx_tmp) {
		HX_STACK_DO_THROW((HX_("Bad node type, expected Element or Document but found ",a0,d6,ba,79) + ::_Xml::XmlType_Impl__obj::toString(this->nodeType)));
	}
	if (::hx::IsNotNull( x->parent )) {
		x->parent->children->remove(x);
	}
	this->children->insert(pos,x);
	x->parent = ::hx::ObjectPtr<OBJ_>(this);
}


HX_DEFINE_DYNAMIC_FUNC2(Xml_obj,insertChild,(void))

::String Xml_obj::toString(){
	return ::haxe::xml::Printer_obj::print(::hx::ObjectPtr<OBJ_>(this),null());
}


HX_DEFINE_DYNAMIC_FUNC0(Xml_obj,toString,return )

void Xml_obj::ensureElementType(){
	bool _hx_tmp;
	if ((this->nodeType != ::Xml_obj::Document)) {
		_hx_tmp = (this->nodeType != ::Xml_obj::Element);
	}
	else {
		_hx_tmp = false;
	}
	if (_hx_tmp) {
		HX_STACK_DO_THROW((HX_("Bad node type, expected Element or Document but found ",a0,d6,ba,79) + ::_Xml::XmlType_Impl__obj::toString(this->nodeType)));
	}
}


HX_DEFINE_DYNAMIC_FUNC0(Xml_obj,ensureElementType,(void))

int Xml_obj::Element;

int Xml_obj::PCData;

int Xml_obj::CData;

int Xml_obj::Comment;

int Xml_obj::DocType;

int Xml_obj::ProcessingInstruction;

int Xml_obj::Document;

 ::Xml Xml_obj::parse(::String str){
	return ::haxe::xml::Parser_obj::parse(str,null());
}


STATIC_HX_DEFINE_DYNAMIC_FUNC1(Xml_obj,parse,return )

 ::Xml Xml_obj::createElement(::String name){
            	HX_JUST_GC_STACKFRAME
	 ::Xml xml =  ::Xml_obj::__alloc( HX_CTX ,::Xml_obj::Element);
	{
		if ((xml->nodeType != ::Xml_obj::Element)) {
			HX_STACK_DO_THROW((HX_("Bad node type, expected Element but found ",d8,90,8b,bb) + ::_Xml::XmlType_Impl__obj::toString(xml->nodeType)));
		}
		xml->nodeName = name;
	}
	return xml;
}


STATIC_HX_DEFINE_DYNAMIC_FUNC1(Xml_obj,createElement,return )

 ::Xml Xml_obj::createPCData(::String data){
            	HX_JUST_GC_STACKFRAME
	 ::Xml xml =  ::Xml_obj::__alloc( HX_CTX ,::Xml_obj::PCData);
	{
		bool _hx_tmp;
		if ((xml->nodeType != ::Xml_obj::Document)) {
			_hx_tmp = (xml->nodeType == ::Xml_obj::Element);
		}
		else {
			_hx_tmp = true;
		}
		if (_hx_tmp) {
			HX_STACK_DO_THROW((HX_("Bad node type, unexpected ",be,79,d5,11) + ::_Xml::XmlType_Impl__obj::toString(xml->nodeType)));
		}
		xml->nodeValue = data;
	}
	return xml;
}


STATIC_HX_DEFINE_DYNAMIC_FUNC1(Xml_obj,createPCData,return )

 ::Xml Xml_obj::createCData(::String data){
            	HX_JUST_GC_STACKFRAME
	 ::Xml xml =  ::Xml_obj::__alloc( HX_CTX ,::Xml_obj::CData);
	{
		bool _hx_tmp;
		if ((xml->nodeType != ::Xml_obj::Document)) {
			_hx_tmp = (xml->nodeType == ::Xml_obj::Element);
		}
		else {
			_hx_tmp = true;
		}
		if (_hx_tmp) {
			HX_STACK_DO_THROW((HX_("Bad node type, unexpected ",be,79,d5,11) + ::_Xml::XmlType_Impl__obj::toString(xml->nodeType)));
		}
		xml->nodeValue = data;
	}
	return xml;
}


STATIC_HX_DEFINE_DYNAMIC_FUNC1(Xml_obj,createCData,return )

 ::Xml Xml_obj::createComment(::String data){
            	HX_JUST_GC_STACKFRAME
	 ::Xml xml =  ::Xml_obj::__alloc( HX_CTX ,::Xml_obj::Comment);
	{
		bool _hx_tmp;
		if ((xml->nodeType != ::Xml_obj::Document)) {
			_hx_tmp = (xml->nodeType == ::Xml_obj::Element);
		}
		else {
			_hx_tmp = true;
		}
		if (_hx_tmp) {
			HX_STACK_DO_THROW((HX_("Bad node type, unexpected ",be,79,d5,11) + ::_Xml::XmlType_Impl__obj::toString(xml->nodeType)));
		}
		xml->nodeValue = data;
	}
	return xml;
}


STATIC_HX_DEFINE_DYNAMIC_FUNC1(Xml_obj,createComment,return )

 ::Xml Xml_obj::createDocType(::String data){
            	HX_JUST_GC_STACKFRAME
	 ::Xml xml =  ::Xml_obj::__alloc( HX_CTX ,::Xml_obj::DocType);
	{
		bool _hx_tmp;
		if ((xml->nodeType != ::Xml_obj::Document)) {
			_hx_tmp = (xml->nodeType == ::Xml_obj::Element);
		}
		else {
			_hx_tmp = true;
		}
		if (_hx_tmp) {
			HX_STACK_DO_THROW((HX_("Bad node type, unexpected ",be,79,d5,11) + ::_Xml::XmlType_Impl__obj::toString(xml->nodeType)));
		}
		xml->nodeValue = data;
	}
	return xml;
}


STATIC_HX_DEFINE_DYNAMIC_FUNC1(Xml_obj,createDocType,return )

 ::Xml Xml_obj::createProcessingInstruction(::String data){
            	HX_JUST_GC_STACKFRAME
	 ::Xml xml =  ::Xml_obj::__alloc( HX_CTX ,::Xml_obj::ProcessingInstruction);
	{
		bool _hx_tmp;
		if ((xml->nodeType != ::Xml_obj::Document)) {
			_hx_tmp = (xml->nodeType == ::Xml_obj::Element);
		}
		else {
			_hx_tmp = true;
		}
		if (_hx_tmp) {
			HX_STACK_DO_THROW((HX_("Bad node type, unexpected ",be,79,d5,11) + ::_Xml::XmlType_Impl__obj::toString(xml->nodeType)));
		}
		xml->nodeValue = data;
	}
	return xml;
}


STATIC_HX_DEFINE_DYNAMIC_FUNC1(Xml_obj,createProcessingInstruction,return )

 ::Xml Xml_obj::createDocument(){
            	HX_JUST_GC_STACKFRAME
	return  ::Xml_obj::__alloc( HX_CTX ,::Xml_obj::Document);
}


STATIC_HX_DEFINE_DYNAMIC_FUNC0(Xml_obj,createDocument,return )


::hx::ObjectPtr< Xml_obj > Xml_obj::__new(int nodeType) {
	::hx::ObjectPtr< Xml_obj > __this = new Xml_obj();
	__this->__construct(nodeType);
	return __this;
}

::hx::ObjectPtr< Xml_obj > Xml_obj::__alloc(::hx::Ctx *_hx_ctx,int nodeType) {
	Xml_obj *__this = (Xml_obj*)(::hx::Ctx::alloc(_hx_ctx, sizeof(Xml_obj), true, "Xml"));
	*(void **)__this = Xml_obj::_hx_vtable;
	__this->__construct(nodeType);
	return __this;
}

Xml_obj::Xml_obj()
{
}

void Xml_obj::__Mark(HX_MARK_PARAMS)
{
	HX_MARK_BEGIN_CLASS(Xml);
	HX_MARK_MEMBER_NAME(nodeType,"nodeType");
	HX_MARK_MEMBER_NAME(nodeName,"nodeName");
	HX_MARK_MEMBER_NAME(nodeValue,"nodeValue");
	HX_MARK_MEMBER_NAME(parent,"parent");
	HX_MARK_MEMBER_NAME(children,"children");
	HX_MARK_MEMBER_NAME(attributeMap,"attributeMap");
	HX_MARK_END_CLASS();
}

void Xml_obj::__Visit(HX_VISIT_PARAMS)
{
	HX_VISIT_MEMBER_NAME(nodeType,"nodeType");
	HX_VISIT_MEMBER_NAME(nodeName,"nodeName");
	HX_VISIT_MEMBER_NAME(nodeValue,"nodeValue");
	HX_VISIT_MEMBER_NAME(parent,"parent");
	HX_VISIT_MEMBER_NAME(children,"children");
	HX_VISIT_MEMBER_NAME(attributeMap,"attributeMap");
}

::hx::Val Xml_obj::__Field(const ::String &inName,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 3:
		if (HX_FIELD_EQ(inName,"get") ) { return ::hx::Val( get_dyn() ); }
		if (HX_FIELD_EQ(inName,"set") ) { return ::hx::Val( set_dyn() ); }
		break;
	case 6:
		if (HX_FIELD_EQ(inName,"parent") ) { return ::hx::Val( parent ); }
		if (HX_FIELD_EQ(inName,"remove") ) { return ::hx::Val( remove_dyn() ); }
		if (HX_FIELD_EQ(inName,"exists") ) { return ::hx::Val( exists_dyn() ); }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"nodeType") ) { return ::hx::Val( nodeType ); }
		if (HX_FIELD_EQ(inName,"nodeName") ) { return ::hx::Val( inCallProp == ::hx::paccAlways ? get_nodeName() : nodeName ); }
		if (HX_FIELD_EQ(inName,"children") ) { return ::hx::Val( children ); }
		if (HX_FIELD_EQ(inName,"iterator") ) { return ::hx::Val( iterator_dyn() ); }
		if (HX_FIELD_EQ(inName,"elements") ) { return ::hx::Val( elements_dyn() ); }
		if (HX_FIELD_EQ(inName,"addChild") ) { return ::hx::Val( addChild_dyn() ); }
		if (HX_FIELD_EQ(inName,"toString") ) { return ::hx::Val( toString_dyn() ); }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"nodeValue") ) { return ::hx::Val( inCallProp == ::hx::paccAlways ? get_nodeValue() : nodeValue ); }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"attributes") ) { return ::hx::Val( attributes_dyn() ); }
		if (HX_FIELD_EQ(inName,"firstChild") ) { return ::hx::Val( firstChild_dyn() ); }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"removeChild") ) { return ::hx::Val( removeChild_dyn() ); }
		if (HX_FIELD_EQ(inName,"insertChild") ) { return ::hx::Val( insertChild_dyn() ); }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"attributeMap") ) { return ::hx::Val( attributeMap ); }
		if (HX_FIELD_EQ(inName,"get_nodeName") ) { return ::hx::Val( get_nodeName_dyn() ); }
		if (HX_FIELD_EQ(inName,"set_nodeName") ) { return ::hx::Val( set_nodeName_dyn() ); }
		if (HX_FIELD_EQ(inName,"firstElement") ) { return ::hx::Val( firstElement_dyn() ); }
		break;
	case 13:
		if (HX_FIELD_EQ(inName,"get_nodeValue") ) { return ::hx::Val( get_nodeValue_dyn() ); }
		if (HX_FIELD_EQ(inName,"set_nodeValue") ) { return ::hx::Val( set_nodeValue_dyn() ); }
		if (HX_FIELD_EQ(inName,"elementsNamed") ) { return ::hx::Val( elementsNamed_dyn() ); }
		break;
	case 17:
		if (HX_FIELD_EQ(inName,"ensureElementType") ) { return ::hx::Val( ensureElementType_dyn() ); }
	}
	return super::__Field(inName,inCallProp);
}

bool Xml_obj::__GetStatic(const ::String &inName, Dynamic &outValue, ::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 5:
		if (HX_FIELD_EQ(inName,"CData") ) { outValue = ( CData ); return true; }
		if (HX_FIELD_EQ(inName,"parse") ) { outValue = parse_dyn(); return true; }
		break;
	case 6:
		if (HX_FIELD_EQ(inName,"PCData") ) { outValue = ( PCData ); return true; }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"Element") ) { outValue = ( Element ); return true; }
		if (HX_FIELD_EQ(inName,"Comment") ) { outValue = ( Comment ); return true; }
		if (HX_FIELD_EQ(inName,"DocType") ) { outValue = ( DocType ); return true; }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"Document") ) { outValue = ( Document ); return true; }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"createCData") ) { outValue = createCData_dyn(); return true; }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"createPCData") ) { outValue = createPCData_dyn(); return true; }
		break;
	case 13:
		if (HX_FIELD_EQ(inName,"createElement") ) { outValue = createElement_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"createComment") ) { outValue = createComment_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"createDocType") ) { outValue = createDocType_dyn(); return true; }
		break;
	case 14:
		if (HX_FIELD_EQ(inName,"createDocument") ) { outValue = createDocument_dyn(); return true; }
		break;
	case 21:
		if (HX_FIELD_EQ(inName,"ProcessingInstruction") ) { outValue = ( ProcessingInstruction ); return true; }
		break;
	case 27:
		if (HX_FIELD_EQ(inName,"createProcessingInstruction") ) { outValue = createProcessingInstruction_dyn(); return true; }
	}
	return false;
}

::hx::Val Xml_obj::__SetField(const ::String &inName,const ::hx::Val &inValue,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 6:
		if (HX_FIELD_EQ(inName,"parent") ) { parent=inValue.Cast<  ::Xml >(); return inValue; }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"nodeType") ) { nodeType=inValue.Cast< int >(); return inValue; }
		if (HX_FIELD_EQ(inName,"nodeName") ) { if (inCallProp == ::hx::paccAlways) return ::hx::Val( set_nodeName(inValue.Cast< ::String >()) );nodeName=inValue.Cast< ::String >(); return inValue; }
		if (HX_FIELD_EQ(inName,"children") ) { children=inValue.Cast< ::Array< ::Dynamic> >(); return inValue; }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"nodeValue") ) { if (inCallProp == ::hx::paccAlways) return ::hx::Val( set_nodeValue(inValue.Cast< ::String >()) );nodeValue=inValue.Cast< ::String >(); return inValue; }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"attributeMap") ) { attributeMap=inValue.Cast<  ::haxe::ds::StringMap >(); return inValue; }
	}
	return super::__SetField(inName,inValue,inCallProp);
}

bool Xml_obj::__SetStatic(const ::String &inName,Dynamic &ioValue,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 5:
		if (HX_FIELD_EQ(inName,"CData") ) { CData=ioValue.Cast< int >(); return true; }
		break;
	case 6:
		if (HX_FIELD_EQ(inName,"PCData") ) { PCData=ioValue.Cast< int >(); return true; }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"Element") ) { Element=ioValue.Cast< int >(); return true; }
		if (HX_FIELD_EQ(inName,"Comment") ) { Comment=ioValue.Cast< int >(); return true; }
		if (HX_FIELD_EQ(inName,"DocType") ) { DocType=ioValue.Cast< int >(); return true; }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"Document") ) { Document=ioValue.Cast< int >(); return true; }
		break;
	case 21:
		if (HX_FIELD_EQ(inName,"ProcessingInstruction") ) { ProcessingInstruction=ioValue.Cast< int >(); return true; }
	}
	return false;
}

void Xml_obj::__GetFields(Array< ::String> &outFields)
{
	outFields->push(HX_("nodeType",dc,51,86,f6));
	outFields->push(HX_("nodeName",6d,d1,7c,f2));
	outFields->push(HX_("nodeValue",0f,5e,ee,d5));
	outFields->push(HX_("parent",2a,05,7e,ed));
	outFields->push(HX_("children",3f,19,6a,70));
	outFields->push(HX_("attributeMap",e0,4b,b2,95));
	super::__GetFields(outFields);
};

#ifdef HXCPP_SCRIPTABLE
static ::hx::StorageInfo Xml_obj_sMemberStorageInfo[] = {
	{::hx::fsInt,(int)offsetof(Xml_obj,nodeType),HX_("nodeType",dc,51,86,f6)},
	{::hx::fsString,(int)offsetof(Xml_obj,nodeName),HX_("nodeName",6d,d1,7c,f2)},
	{::hx::fsString,(int)offsetof(Xml_obj,nodeValue),HX_("nodeValue",0f,5e,ee,d5)},
	{::hx::fsObject /*  ::Xml */ ,(int)offsetof(Xml_obj,parent),HX_("parent",2a,05,7e,ed)},
	{::hx::fsObject /* ::Array< ::Dynamic> */ ,(int)offsetof(Xml_obj,children),HX_("children",3f,19,6a,70)},
	{::hx::fsObject /*  ::haxe::ds::StringMap */ ,(int)offsetof(Xml_obj,attributeMap),HX_("attributeMap",e0,4b,b2,95)},
	{ ::hx::fsUnknown, 0, null()}
};
static ::hx::StaticInfo Xml_obj_sStaticStorageInfo[] = {
	{::hx::fsInt,(void *) &Xml_obj::Element,HX_("Element",9c,d6,a5,d3)},
	{::hx::fsInt,(void *) &Xml_obj::PCData,HX_("PCData",bd,3d,a2,bd)},
	{::hx::fsInt,(void *) &Xml_obj::CData,HX_("CData",0d,60,15,c1)},
	{::hx::fsInt,(void *) &Xml_obj::Comment,HX_("Comment",3f,a2,c1,4e)},
	{::hx::fsInt,(void *) &Xml_obj::DocType,HX_("DocType",32,25,de,a5)},
	{::hx::fsInt,(void *) &Xml_obj::ProcessingInstruction,HX_("ProcessingInstruction",db,1e,14,6a)},
	{::hx::fsInt,(void *) &Xml_obj::Document,HX_("Document",3b,ab,c4,74)},
	{ ::hx::fsUnknown, 0, null()}
};
#endif

static ::String Xml_obj_sMemberFields[] = {
	HX_("nodeType",dc,51,86,f6),
	HX_("nodeName",6d,d1,7c,f2),
	HX_("nodeValue",0f,5e,ee,d5),
	HX_("parent",2a,05,7e,ed),
	HX_("children",3f,19,6a,70),
	HX_("attributeMap",e0,4b,b2,95),
	HX_("get_nodeName",76,85,96,a7),
	HX_("set_nodeName",ea,a8,8f,bc),
	HX_("get_nodeValue",e6,31,52,97),
	HX_("set_nodeValue",f2,13,58,dc),
	HX_("get",96,80,4e,00),
	HX_("set",a2,9b,57,00),
	HX_("remove",44,9c,88,04),
	HX_("exists",dc,1d,e0,bf),
	HX_("attributes",d7,a8,71,97),
	HX_("iterator",ee,49,9a,93),
	HX_("elements",37,36,c4,83),
	HX_("elementsNamed",02,e2,8a,c2),
	HX_("firstChild",4c,f3,97,83),
	HX_("firstElement",6c,c4,9c,2f),
	HX_("addChild",bb,cf,16,bf),
	HX_("removeChild",b8,86,ed,43),
	HX_("insertChild",a3,87,6e,8d),
	HX_("toString",ac,d0,6e,38),
	HX_("ensureElementType",78,fa,0e,fc),
	::String(null()) };

static void Xml_obj_sMarkStatics(HX_MARK_PARAMS) {
	HX_MARK_MEMBER_NAME(Xml_obj::Element,"Element");
	HX_MARK_MEMBER_NAME(Xml_obj::PCData,"PCData");
	HX_MARK_MEMBER_NAME(Xml_obj::CData,"CData");
	HX_MARK_MEMBER_NAME(Xml_obj::Comment,"Comment");
	HX_MARK_MEMBER_NAME(Xml_obj::DocType,"DocType");
	HX_MARK_MEMBER_NAME(Xml_obj::ProcessingInstruction,"ProcessingInstruction");
	HX_MARK_MEMBER_NAME(Xml_obj::Document,"Document");
};

#ifdef HXCPP_VISIT_ALLOCS
static void Xml_obj_sVisitStatics(HX_VISIT_PARAMS) {
	HX_VISIT_MEMBER_NAME(Xml_obj::Element,"Element");
	HX_VISIT_MEMBER_NAME(Xml_obj::PCData,"PCData");
	HX_VISIT_MEMBER_NAME(Xml_obj::CData,"CData");
	HX_VISIT_MEMBER_NAME(Xml_obj::Comment,"Comment");
	HX_VISIT_MEMBER_NAME(Xml_obj::DocType,"DocType");
	HX_VISIT_MEMBER_NAME(Xml_obj::ProcessingInstruction,"ProcessingInstruction");
	HX_VISIT_MEMBER_NAME(Xml_obj::Document,"Document");
};

#endif

::hx::Class Xml_obj::__mClass;

static ::String Xml_obj_sStaticFields[] = {
	HX_("Element",9c,d6,a5,d3),
	HX_("PCData",bd,3d,a2,bd),
	HX_("CData",0d,60,15,c1),
	HX_("Comment",3f,a2,c1,4e),
	HX_("DocType",32,25,de,a5),
	HX_("ProcessingInstruction",db,1e,14,6a),
	HX_("Document",3b,ab,c4,74),
	HX_("parse",33,90,55,bd),
	HX_("createElement",20,87,97,ee),
	HX_("createPCData",b9,09,63,ab),
	HX_("createCData",91,27,63,57),
	HX_("createComment",c3,52,b3,69),
	HX_("createDocType",b6,d5,cf,c0),
	HX_("createProcessingInstruction",5f,2e,58,38),
	HX_("createDocument",37,6e,4d,ed),
	::String(null())
};

void Xml_obj::__register()
{
	Xml_obj _hx_dummy;
	Xml_obj::_hx_vtable = *(void **)&_hx_dummy;
	::hx::Static(__mClass) = new ::hx::Class_obj();
	__mClass->mName = HX_("Xml",b7,25,43,00);
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &Xml_obj::__GetStatic;
	__mClass->mSetStaticField = &Xml_obj::__SetStatic;
	__mClass->mMarkFunc = Xml_obj_sMarkStatics;
	__mClass->mStatics = ::hx::Class_obj::dupFunctions(Xml_obj_sStaticFields);
	__mClass->mMembers = ::hx::Class_obj::dupFunctions(Xml_obj_sMemberFields);
	__mClass->mCanCast = ::hx::TCanCast< Xml_obj >;
#ifdef HXCPP_VISIT_ALLOCS
	__mClass->mVisitFunc = Xml_obj_sVisitStatics;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = Xml_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = Xml_obj_sStaticStorageInfo;
#endif
	::hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

void Xml_obj::__boot()
{
{
	Element = 0;
}
{
	PCData = 1;
}
{
	CData = 2;
}
{
	Comment = 3;
}
{
	DocType = 4;
}
{
	ProcessingInstruction = 5;
}
{
	Document = 6;
}
}

